import { Entity, EntityQuery, EntityType, MetadataStore, EntityChangedEventArgs, EntityAction, MergeStrategy, QueryOptions, FetchStrategy, EntityManager, EntityAspect, Predicate, SaveOptions, EntityProperty, EntityState, AutoGeneratedKeyType } from 'breeze-client';
import { TestFns, JsonObj } from './test-fns';
import { ValidationErrorsChangedEventArgs } from 'src/entity-manager';

TestFns.initServerEnv();

beforeAll(async () => {
  await TestFns.initDefaultMetadataStore();

});

describe("EntityManager Save", () => {

  beforeEach(function () {

  });

  test("update with client concurrency update with null rowVersion", async () => {
    expect.hasAssertions();
    let cust: Entity, rowVersion: number;
    const em1 = TestFns.newEntityManager();

    const q1 = new EntityQuery("Customers").where("rowVersion", "==", null).take(1);
    const data = await em1.executeQuery(q1);
    cust = data.results[0];
    TestFns.morphStringProp(cust, "contactName");
    rowVersion = cust.getProperty("rowVersion");
    const sr = await em1.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    expect(cust.getProperty("rowVersion")).toBe(rowVersion + 1);
  });

  test("update with client concurrency update with non-null rowVersion", async function () {
    expect.hasAssertions();
    
    const em1 = TestFns.newEntityManager();

    const qr1 = await em1.executeQuery(new EntityQuery("Customers")
      .where("rowVersion", "!=", null)
      .where("companyName", "!=", "error")
      .take(1));
    const cust = qr1.results[0];
    TestFns.morphStringProp(cust, "contactName");
    const rowVersion = cust.getProperty("rowVersion");
    const sr = await em1.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    expect(cust.getProperty("rowVersion")).toBe(rowVersion + 1);
  });

  test("update order", async () => {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("customerID", "!=", null).take(1);
    const qr1 = await em.executeQuery(q);
    const orders = qr1.results;
    expect(orders.length).toBe(1);
    const order = orders[0];
    const customerId = order.getProperty("customerID");
    const freight = order.getProperty("freight");
    const offset = (Math.random() * 2 | 0) ? 0.01 : -0.01;
    order.setProperty("freight", freight + offset);
    const sr = await em.saveChanges();
    const entities = sr.entities;
    expect(entities.length).toBe(1);
    expect(entities[0]).toBe(order);
    expect(order.getProperty("customerID")).not.toBeNull;
  });

  test("insert multipart entity", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const product = createProduct(em);
    const order = createOrder(em);
    const sr0 = await em.saveChanges();

    expect(sr0.entities.length).toBe(2);
    const orderDetail = createOrderDetail(em, order, product);
    const orderID = order.getProperty("orderID");
    const productID = product.getProperty("productID");
    expect(orderID).not.toBe(0);
    expect(productID).not.toBe(0);
    const odOrderID_1 = orderDetail.getProperty("orderID");
    const odProductID_1 = orderDetail.getProperty("productID");
    expect(orderID).toBe(odOrderID_1);
    expect(productID).toBe(odProductID_1);
    const sr = await em.saveChanges();

    expect(sr.entities.length).toBe(1);
    const orderIDx = order.getProperty("orderID");
    const productIDx = product.getProperty("productID");
    // expect(orderID).not.toBe(orderIDx, "orderID should have changed");
    // expect(productID).not.toBe(productIDx, "productID should have changed");
    const odOrderIDx = orderDetail.getProperty("orderID");
    const odProductIDx = orderDetail.getProperty("productID");
    expect(orderIDx).toBe(odOrderIDx);
    expect(productIDx).toBe(odProductIDx);
    // hack should not be necessary.
    // orderDetail.setProperty("productID", productIDx);
    orderDetail.setProperty("unitPrice", 10);
    const sr2 = await em.saveChanges();

    expect(sr2.entities.length).toBe(1);
  });

  // bug is with fixup of the 2nd part of the pk
  test("insert multipart entity 2", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const order = createOrder(em);
    const product = createProduct(em);
    const orderDetail = createOrderDetail(em, order, product);

    const orderID = order.getProperty("orderID");
    const productID = product.getProperty("productID");
    expect(orderID).not.toBe(0);
    expect(productID).not.toBe(0);
    const odOrderID = orderDetail.getProperty("orderID");
    const odProductID = orderDetail.getProperty("productID");
    expect(orderID).toBe(odOrderID);
    expect(productID).toBe(odProductID);

    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(3);
    expect(sr.entities).toContain(product);
    expect(sr.entities).toContain(order);
    expect(sr.entities).toContain(orderDetail);
    const orderIDx = order.getProperty("orderID");
    const productIDx = product.getProperty("productID");
    expect(orderID).not.toBe(orderIDx);
    expect(productID).not.toBe(productIDx);
    const odOrderIDx = orderDetail.getProperty("orderID");
    const odProductIDx = orderDetail.getProperty("productID");
    expect(orderIDx).toBe(odOrderIDx);
    expect(productIDx).toBe(odProductIDx);
    // hack should not be necessary.
    // orderDetail.setProperty("productID", productIDx);
    orderDetail.setProperty("unitPrice", 10);
    const sr2 = await em.saveChanges();
    expect(sr2.entities.length).toBe(1);

  });

  test("hasChangesChanged event raised after saveChanges", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();

    let hasChangesChangedRaised: boolean[] = [];
    em.hasChangesChanged.subscribe(
      function (eventArgs) {
        hasChangesChangedRaised.push(eventArgs.hasChanges);
      }
    );

    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");


    await em.saveChanges();
    expect(hasChangesChangedRaised.length).toBe(2);
    expect(hasChangesChangedRaised[0]).toBe(true);
    expect(hasChangesChangedRaised[1]).toBe(false);
    expect(em.hasChanges()).toBe(false);
  });

  
  test("delete without query", function () {
    expect.hasAssertions();
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;
    const em = TestFns.newEntityManager();
    const em2 = TestFns.newEntityManager();
    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);

    let similarEmp: Entity, similarAspect: EntityAspect;
    em.saveChanges().then(function (sr) {
      const savedEnts = sr.entities;
      expect(savedEnts.length).toBe(1);
      expect(emp).toBe(savedEnts[0]);
      const empKeyValue = emp.getProperty(employeeKeyName);
      const empKey = emp.entityAspect.getKey();
      const empVersion = emp.getProperty("rowVersion");
      similarEmp = em2.createEntity("Employee");
      similarEmp.setProperty(employeeKeyName, empKeyValue);
      similarEmp.setProperty("rowVersion", empVersion);
      similarAspect = similarEmp.entityAspect;
      similarAspect.setUnchanged();
      similarAspect.setDeleted();
      expect(similarAspect.entityState.isDeleted()).toBe(true);
      return em2.saveChanges();
    }).then(function (sr) {
      const savedEnts = sr.entities;
      expect(savedEnts.length).toBe(1);
      expect(savedEnts[0]).toBe(similarEmp);
      expect(similarAspect.entityState.isDetached()).toBe(true);
    });


  });

  //TestFns.skipIf("mongo", " can not handle this test as written").
  test("pk update should throw meaningful exception", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Territories").orderBy("territoryID desc").take(1);

    try {
      const qr1 = await q.using(em).execute();
      expect(qr1.results.length).toBe(1);
      const terr = qr1.results[0];
      const id = terr.getProperty("territoryID");
      terr.setProperty("territoryID", id + 1);
      const sr = await em.saveChanges();
      throw 'should not get here';
    } catch (e) {
      let isOk;
      if (TestFns.isHibernateServer) {
        isOk = e.message.toLowerCase().indexOf("row was updated or deleted by another") >= 0;
      }
      else if (TestFns.isAspCoreServer) {
        isOk = e.message.toLowerCase().indexOf("data may have been modified or") >= 0;
      }
      else {
        isOk = e.message.indexOf("part of the entity's key") > 0;
      }
      expect(isOk).toBe(true);
    }
  });

  
  test("product update active", async function () {
    expect.assertions(2);
    await updateProduct(4);
  });

  
  test("product update discontinued", async function () {
    expect.assertions(2);
    await updateProduct(5);
  });

  async function updateProduct(productId: number) {

    const em = TestFns.newEntityManager();

    const q = new EntityQuery("Products").where("productID", "eq", productId);

    
    const qr1 = await q.using(em).execute();
    expect(qr1.results.length).toBe(1);
    const product = qr1.results[0];
    const unitsInStock = product.getProperty("unitsInStock");
    product.setProperty("unitsInStock", unitsInStock + 10);
    const sr1 = await em.saveChanges();
    expect(true).toBe(true);
  }

  //TestFns.skipIf("mongo", " can not handle this test as written").
  test("add entity with enum and related - UserRole", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const userId = 6;
    //const p2 = breeze.Predicate.create("userId", "ne", userId);
    //const p1 = breeze.Predicate.create("userRoles", "all", p2);
    const p2 = Predicate.create("userId", "==", userId);
    const p1 = Predicate.create("userRoles", "any", p2).not();

    const q = new EntityQuery("Roles").where(p1).take(1);

    
    const data = await q.using(em).execute();
    expect(data.results.length).toBe(1);
    const role = data.results[0];
    const roleId = role.getProperty("id");
    const newUserRole = em.createEntity('UserRole', {
      userId: userId,
      roleId: roleId
    });
    const sr = await em.saveChanges();
    const resultRole = sr.entities[0];
    const roleId2 = resultRole.getProperty("roleId");
    expect(roleId2).toBe(roleId);
    const userId2 = resultRole.getProperty("userId");
    expect(userId2).toBe(userId);
    // delete entity
    resultRole.entityAspect.setDeleted();
    await em.saveChanges();
    
  });

  //TestFns.skipIf("mongo,odata,sequelize", "does not yet support enums").
  test("new entity with enum", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const em2 = TestFns.newEntityManager();
    const roleType = em.metadataStore.getEntityType("Role");

    const aRole = em.createEntity("Role");
    aRole.setProperty("roleType", "Restricted");
    aRole.setProperty("name", "TEMP" + TestFns.makeTempString(5));
    const ves = aRole.entityAspect.validateEntity();
    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(1);
    aRole.setProperty("roleType", "Guest");
    const sr2 = await em.saveChanges();
    expect(sr2.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(aRole);
    const data = await em2.executeQuery(q2);
    const roles = data.results;
    expect(roles.length).toBe(1);
    const aRole2 = roles[0];
    const rt = aRole2.getProperty("roleType");
    expect(rt).toBe("Guest");
    // throw away 'set' because the object is going to be deleted anyway.
    aRole2.setProperty("roleType", "Restricted");
    aRole2.entityAspect.setDeleted();
    const sr3 = await em2.saveChanges();
    expect(sr3.entities.length).toBe(1);
    expect(aRole2.entityAspect.entityState.isDetached()).toBe(true);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("exceptions thrown on server", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").take(1);

    try {
      const data = await q.using(em).execute();
      const order = data.results[0];
      const freight = order.getProperty("freight") + 0.5;
      order.setProperty("freight", freight);
      const so = new SaveOptions({ resourceName: "SaveAndThrow", tag: "SaveAndThrow" });
      const sr = await em.saveChanges(null, so);
      throw new Error("should not get here");
    } catch (e) {
      expect(e).toBeTruthy();
    }
  });

  test("delete entity with Int32 property set to null", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const c1 = em.createEntity("Order", { employeeID: 1 });
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;

    //save entity with non-null value on Int32 field
    const sr = await em.saveChanges();
    const order = sr.entities[0];
    const empId0 = order.getProperty(employeeKeyName);
    expect(empId0).not.toBeNull;
    //set the Int32 field to null
    order.setProperty(employeeKeyName, null);
    const sr1 = await em.saveChanges();
    const order1 = sr1.entities[0];
    const empId1 = order1.getProperty(employeeKeyName);
    expect(empId1).toBeNull;
    //mark entity as deleted
    order1.entityAspect.setDeleted();
    await em.saveChanges();
    
  });

  
  test("check unmapped property on server", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const customerType = em.metadataStore.getAsEntityType("Customer");

    const Customer = function () {
      this.myUnmappedProperty = "anything22";
    };
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    const entitiesToSave = new Array(cust);
    const saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedProperty" });

    await em.saveChanges(entitiesToSave, saveOptions);
    expect(true).toBe(true);
  });

  
  test("unmapped property serialization on server", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const customerType = em.metadataStore.getAsEntityType("Customer");
    customerType.setProperties({
      serializerFn: function (dp: EntityProperty, value: any) {
        if (typeof (value) === "string") return value.toUpperCase();
        if (dp.isUnmapped) {
          if (dp.name === "anotherOne") {
            value.extra = 666;
          }
        }
        return value;
      }
    });
    const Customer = getWierdCustomerCtor();
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    const entitiesToSave = new Array(cust);
    const saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedPropertySerialized" });


    const sr = await em.saveChanges(entitiesToSave, saveOptions);
    expect(true).toBe(true);
  });

  test("unmapped property suppression", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const customerType = em.metadataStore.getAsEntityType("Customer");
    customerType.setProperties({
      serializerFn: function (dp, value) {
        if (dp.isUnmapped) return undefined;
        return value;
      }
    });
    const Customer = getWierdCustomerCtor();
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);


    const cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    const entitiesToSave = new Array(cust);
    const saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedPropertySuppressed" });

    await em.saveChanges(entitiesToSave, saveOptions);
    expect(true).toBe(true);
  });

  test("check initializer is hit for entities added/saved on server", async function () {
    expect.assertions(2);
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const ordInitializer = function (ord: Entity) {
      ord.setProperty("shipCountry", "Brazil");
    };

    em.metadataStore.registerEntityTypeCtor("Order", null, ordInitializer);

    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);
    const so = new SaveOptions({ resourceName: "SaveCheckInitializer" });

    const sr = await em.saveChanges(null, so);
    const ents = sr.entities;
    expect(ents.length).toBe(2);
    ents.forEach(function (ent) {
      if (ent.entityType.shortName === "Order") {
        expect(ent.getProperty("shipCountry")).toBe("Brazil");
      }
    });
  });

  // //TestFns.skipIf("odata", "does not support server side interception or alt resource").
  test("entities retrieved on server being modified and resaved", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();

    const q = EntityQuery.from("Categories").where("categoryName", "startsWith", "Beverage");

    const data = await em.executeQuery(q);
    const category = data.results[0];
    TestFns.morphStringProp(category, "categoryName");
    const entitiesToSave = new Array(category);
    const saveOptions = new SaveOptions({ tag: "increaseProductPrice" });
    const sr = await em.saveChanges(entitiesToSave, saveOptions);
    expect(sr.entities.length).toBe(13);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("data with additional entity added on server", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();

    const supplier = em.createEntity("Supplier", { companyName: "CompName" });
    const entitiesToSave = new Array(supplier);
    const saveOptions = new SaveOptions({ tag: "addProdOnServer" });

    const sr = await em.saveChanges(entitiesToSave, saveOptions);
    const addedProducts = em.getEntities(["Product"], EntityState.Added);
    expect(addedProducts.length).toBe(0);
  });


  test("can save a Northwind Order & InternationalOrder", async function () {
    expect.hasAssertions();

    // Create and initialize entity to save
    const em = TestFns.newEntityManager();

    const order = em.createEntity('Order', {
      customerID: TestFns.wellKnownData.alfredsID,
      employeeID: TestFns.wellKnownData.nancyID,
      shipName: "Test " + new Date().toISOString()
    });

    const internationalOrder = em.createEntity('InternationalOrder', {
      // I thought Jay fixed this?
      order: order, // sets OrderID and pulls it into the order's manager
      // orderID: order.getProperty("orderID"),
      customsDescription: "rare, exotic birds"
    });

    const data = await em.saveChanges();
    const orderId = order.getProperty("orderID");
    const internationalOrderID = internationalOrder.getProperty("orderID");
    expect(internationalOrderID).toBe(orderId);
    expect(orderId).toBeGreaterThan(0);
  });

  test("can save a Northwind Order & OrderDetail", async function () {
    expect.hasAssertions();

    // Create and initialize entity to save
    const em = TestFns.newEntityManager();

    const order = em.createEntity('Order', {
      customerID: TestFns.wellKnownData.alfredsID,
      employeeID: TestFns.wellKnownData.nancyID,
      shipName: "Test " + new Date().toISOString()
    });

    const orderDetail1 = em.createEntity('OrderDetail', {
      order: order, // sets OrderID and pulls it into the order's manager
      productID: TestFns.wellKnownData.chaiProductID, // wellKnownData.alfredsOrderDetailKey.ProductID
      quantity: 5
    });
    const orderDetail2 = em.createEntity('OrderDetail', {
      order: order, // sets OrderID and pulls it into the order's manager
      productID: TestFns.wellKnownData.alfredsOrderDetailKey.ProductID,
      quantity: 6
    });

    const data = await em.saveChanges();
    const orderId = order.getProperty("orderID");
    expect(orderId).toBeGreaterThan(0);

  });


  test("save with date as part of key", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const dt = new Date();
    dt.setUTCMilliseconds(100);
    const c1 = em.createEntity("Comment", { createdOn: dt, seqNum: 1, comment1: "now is the time for" });
    const c2 = em.createEntity("Comment", { createdOn: dt, seqNum: 2, comment1: "and again" });

    const sr = await em.saveChanges();
    const comments = sr.entities;
    expect(comments.length).toBe(2);
    const em2 = TestFns.newEntityManager();
    const q = EntityQuery.from("Comments").where("createdOn", "==", dt);
    const data = await em2.executeQuery(q);
    const comments2 = data.results;
    expect(comments2.length).toBe(2);
  });

  test("computed update", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const q = EntityQuery.from("Employees").take(3);

    const data = await em.executeQuery(q);
    const emps = data.results;
    TestFns.morphStringProp(emps[0], "lastName");
    const sr = await em.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    const emp = ents[0];
    const fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
    if (TestFns.isODataServer) {
      // fullNames will not match with ODATA because no records are returned after save;
      expect(fullName !== emp.getProperty("fullName")).toBe(true);
    } else {
      expect(fullName).toBe(emp.getProperty("fullName"));
    }
  });

  //TestFns.skipIf("sequelize,hibernate", "does not yet support computed properties").
  test("computed update - mod computed", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const q = EntityQuery.from("Employees").take(3);

    const data = await em.executeQuery(q);
    const emps = data.results;
    TestFns.morphStringProp(emps[0], "lastName");
    emps[0].setProperty("fullName", "xxx");
    const sr = await em.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    const emp = ents[0];
    const fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
    if (TestFns.isODataServer) {
      // fullNames will not match with ODATA because no records are returned after save;
      expect(fullName !== emp.getProperty("fullName")).toBe(true);
    } else {
      expect(fullName).toBe(emp.getProperty("fullName"));
    }
  });

  //TestFns.skipIf("sequelize,hibernate", "does not yet support computed properties").
  test("computed insert", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);

    const sr = await em.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    expect(ents[0]).toBe(emp);
    const fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
    expect(fullName).toBe(emp.getProperty("fullName"));
  });

  test("update with unmapped changes", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = function () {
      this.miscData = "asdf";
    };
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const q = new EntityQuery("Customers").take(1);
    const qr1 = await em1.executeQuery(q);
    const custType = em1.metadataStore.getEntityType("Customer");
    const cust = qr1.results[0];
    const oldContactName = cust.getProperty("contactName");
    const oldMiscData = cust.getProperty("miscData");
    TestFns.morphStringProp(cust, "contactName");
    TestFns.morphStringProp(cust, "miscData");
    const sr = await em1.saveChanges();
    const e = sr.entities;
    expect(e.length).toBe(1);
  });

  // Test asserts will fail for OData until we fix #2574
  // "entityAspect.extraMetdata not preserved after export/import"
  test("update after exporting and reimporting a customer", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const q1 = new EntityQuery("Customers").take(1).using(em1);
    const qr1 = await q1.execute();
    let cust = qr1.results[0];
    let extraMetadata;
    if (TestFns.isODataServer) {
      extraMetadata = cust.entityAspect.extraMetadata;
      // has OData extraMetadata on the original customer before export
      expect(extraMetadata).toBeTruthy();
    }
    const exported = em1.exportEntities([cust], { includeMetadata: false }); // exclude metadata ... not important
    cust.entityAspect.setDetached(); // remove from cache
    cust = em1.importEntities(exported).entities[0]; // get reimported customer
    if (TestFns.isODataServer) {
      // these tests fail for OData until #2574 fixed
      const xtra = cust.entityAspect.extraMetadata;
      // has extraMetadata on the imported customer
      expect(xtra).toBeTruthy();
      expect(xtra.etag).toBe(extraMetadata.etag);
    }
    TestFns.morphStringProp(cust, "contactName");
    const sr = await em1.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
  });

  test("update with ES5 props and unmapped changes", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = TestFns.getCustomerWithES5PropsCtor();
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const q = new EntityQuery("Customers").take(1);
    const qr1 = await em1.executeQuery(q);
    const custType = em1.metadataStore.getEntityType("Customer");
    const cust = qr1.results[0];
    const oldContactName = cust.getProperty("contactName");
    const oldMiscData = cust.getProperty("miscData");
    TestFns.morphStringProp(cust, "contactName");
    TestFns.morphStringProp(cust, "miscData");
    const sr = await em1.saveChanges();
    const e = sr.entities;
    expect(e.length).toBe(1);
  });

  test("delete with unmapped changes", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = function () {
      this.miscData = "asdf";
    };
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);
    
    await em1.fetchMetadata();
    const zzz = createParentAndChildren(em1);
    const saveResult = await em1.saveChanges();
    const cust = zzz.cust1;
    const oldContactName = cust.getProperty("contactName");
    const oldMiscData = cust.getProperty("miscData");
    TestFns.morphStringProp(cust, "contactName");
    TestFns.morphStringProp(cust, "miscData");
    zzz.cust1.entityAspect.setDeleted();
    const sr = await em1.saveChanges();
    const r = sr.entities;
    expect(zzz.cust1.entityAspect.entityState.isDetached());
    expect(r.length).toBe(3);

  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with server reject", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();

    const user = em.createEntity("Region");

    user.setProperty("regionDescription", "error here");
    em.addEntity(user);
    let hasChanges = em.hasChanges();
    expect(hasChanges).toBe(true);

    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(0);
    hasChanges = em.hasChanges();
    expect(hasChanges).toBe(true);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("set audit field on user create", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const user = em.createEntity("User");
    user.setProperty("userName", "Test" + Date.now());
    user.setProperty("userPassword", "" + Date.now());
    user.setProperty("firstName", "Test");
    user.setProperty("lastName", "Test");
    user.setProperty("email", "test@test.com");

    em.addEntity(user);
    const hasChanges = em.hasChanges();
    expect(hasChanges).toBe(true);
    const so = new SaveOptions({ resourceName: "SaveWithAuditFields" });

    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    sr.entities.forEach(function (e: any) {
      expect(e.createdByUserId).toBe(12345);
    });
  });

  test("user update", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Users").where("id", "eq", 4);
    
    const email = "u" + Date.now() + "@ideablade.com";
    const qr1 = await q.using(em).execute();
    const user = qr1.results[0];
    user.setProperty("email", email);
    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(1);
    sr.entities.forEach(function (e: any) {
      expect(e.email).toBe(email);
    });
  });


  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("set audit field on user update", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Users").where("id", "eq", 4);

    const data = await q.using(em).execute();
    const user = data.results[0];
    user.setProperty("email", "u" + Date.now() + "@ideablade.com");
    const so = new SaveOptions({ resourceName: "SaveWithAuditFields" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    sr.entities.forEach(function (e: any) {
      expect(e.modifiedByUserId).toBe(12345);
    });
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server side add", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).take(1).orderBy("orderID");

    const qr1 = await q.using(em).execute();
    const order = qr1.results[0];
    const freight = order.getProperty("freight") + 0.5;
    order.setProperty("freight", freight);
    const so = new SaveOptions({ resourceName: "SaveWithComment", tag: "SaveWithComment - order" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(2);
    sr.entities.forEach(function (e) {
      expect(e.entityAspect).toBeTruthy();
    });
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server update", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(1).take(1).orderBy("orderID");

    const data = await q.using(em).execute();
    const order = data.results[0];
    const freight = order.getProperty("freight") + 0.5;
    order.setProperty("freight", freight);
    const so = new SaveOptions({ resourceName: "SaveWithFreight2", tag: "freight update" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight + 1);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server update - ForceUpdate", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(2).take(1).orderBy("orderID");


    const data = await q.using(em).execute();
    const order = data.results[0];
    const freight = order.getProperty("freight");
    const shipCountry = TestFns.morphString(order.getProperty("shipCountry"));
    order.setProperty("shipCountry", shipCountry);
    const so = new SaveOptions({ resourceName: "SaveWithFreight", tag: "freight update-force" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight + 1);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with server update - original values fixup", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(3).take(1).orderBy("orderID");

    const data = await q.using(em).execute();
    const order = data.results[0];
    const freight = order.getProperty("freight");
    const shipCity = TestFns.morphString(order.getProperty("shipCountry"));
    order.setProperty("shipCountry", shipCity);
    const so = new SaveOptions({ resourceName: "SaveWithFreight", tag: "freight update-ov" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight + 1);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with saveOptions exit", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = createParentAndChildren(em);
    const cust1 = zzz.cust1;
    const so = new SaveOptions({ resourceName: "SaveWithExit", tag: "exit" });

    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(0);
  });

  // //TestFns.skipIf("odata", "does not support server interception or alt resources").
  // test("adds with EntityErrorsException", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);
  //   const cust1 = zzz.cust1;
  //   const so = new SaveOptions({ resourceName: "SaveWithEntityErrorsException", tag: "entityErrorsException" });
  //   const order1ValErrorsChangedArgs: ValidationErrorsChangedEventArgs[] = [];
  //   zzz.order1.entityAspect.validationErrorsChanged.subscribe(function (e: ValidationErrorsChangedEventArgs) {
  //     order1ValErrorsChangedArgs.push(e);
  //   });

  //   return em.saveChanges(null, so).then(function (sr) {
  //     expect(false, "should not get here");

  //   }).catch(function (e) {
  //     expect(e.message.indexOf("test of custom exception message") >= 0, "wrong custom error message: " + e.message);
  //     expect(order1ValErrorsChangedArgs.length).toBe(1, "should have had order1ValErrorsChangedArgs");
  //     expect(order1ValErrorsChangedArgs[0].added.length).toBe(1, "should have added 1");
  //     expect(order1ValErrorsChangedArgs[0].removed.length).toBe(0, "should have added 1");
  //     expect(e.entityErrors, "should have server errors");
  //     expect(e.entityErrors.length).toBe(2, "2 order entities should have failed");
  //     expect(zzz.order1.entityAspect.getValidationErrors().length).toBe(1);
  //     const order2Errs = zzz.order2.entityAspect.getValidationErrors();
  //     expect(order2Errs.length).toBe(1, "should be 1 error for order2");
  //     expect(order2Errs[0].propertyName).toBe("orderID", "errant property should have been 'orderID'");
  //     // now save it properly
  //     order1ValErrorsChangedArgs.length = 0;

  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(sr.entities.length).toBe(4, "should have saved ok");
  //     expect(order1ValErrorsChangedArgs.length).toBe(1, "should have had order1ValErrorsChangedArgs");
  //     expect(order1ValErrorsChangedArgs[0].added.length).toBe(0, "should have removed 1");
  //     expect(order1ValErrorsChangedArgs[0].removed.length).toBe(1, "should have removed 1");
  //   });

  // });

  // //TestFns.skipIf("odata", "does not support server interception or alt resources").

  // test("mods with EntityErrorsException", function () {
  //   expect.hasAssertions();

  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);
  //   const cust1 = zzz.cust1;


  //   em.saveChanges().then(function (sr) {
  //     zzz.cust1.setProperty("contactName", "foo");
  //     zzz.cust2.setProperty("contactName", "foo");
  //     zzz.order1.setProperty("freight", 888.11);
  //     zzz.order2.setProperty("freight", 888.11);
  //     expect(zzz.cust1.entityAspect.entityState.isModified(), "cust1 should be modified");
  //     expect(zzz.order1.entityAspect.entityState.isModified(), "order1 should be modified");
  //     const so = new SaveOptions({ resourceName: "SaveWithEntityErrorsException", tag: "entityErrorsException" });
  //     return em.saveChanges(null, so);
  //   }).then(function (sr2) {
  //     expect(false, "should not get here");
  //   }).catch(function (e) {
  //     expect(e.message).toBe("test of custom exception message", "wrong custom error message: " + e.message);
  //     expect(e.entityErrors, "should have server errors");
  //     expect(e.entityErrors.length).toBe(2, "2 order entities should have failed");
  //     expect(zzz.order1.entityAspect.getValidationErrors().length).toBe(1);
  //     const order2Errs = zzz.order2.entityAspect.getValidationErrors();
  //     expect(order2Errs.length).toBe(1, "should be 1 error for order2");
  //     expect(order2Errs[0].propertyName).toBe("orderID", "errant property should have been 'orderID'");
  //     // now save it properly
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(sr.entities.length).toBe(4, "should have saved ok");
  //   });

  // });

  // test("with client side validation error", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);
  //   const cust1 = zzz.cust1;
  //   cust1.setProperty("companyName", null);

  //   em.saveChanges().then(function (sr) {
  //     expect(false, "should not get here");
  //   }).catch(function (e) {
  //     expect(e.entityErrors, "should be a  entityError");
  //     expect(e.entityErrors.length).toBe(1, "should be only one error");
  //     expect(!e.entityErrors[0].isServerError, "should NOT be a server error");
  //     const errors = cust1.entityAspect.getValidationErrors();
  //     expect(errors[0].errorMessage).toBe(errors[0].errorMessage, "error message should appear on the cust");

  //   }).fin(done);
  // });

  // //TestFns.skipIf("odata", "does not support server interception or alt resources").
  // // skipIf("mongo", "has not yet implemented this").
  // // skipIf("hibernate", "is not applicable because this test uses EF validation annotations")
  // test("with server side entity level validation error", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);
  //   const cust1 = zzz.cust1;
  //   cust1.setProperty("companyName", "error");

  //   em.saveChanges().then(function (sr) {
  //     expect(false, "should not get here");
  //   }).catch(function (e) {
  //     expect(e.entityErrors, "should be a server error");
  //     expect(e.entityErrors.length).toBe(1, "should be only one server error");
  //     const errors = cust1.entityAspect.getValidationErrors();
  //     expect(errors[0].errorMessage).toBe(e.entityErrors[0].errorMessage, "error message should appear on the cust");
  //   }).fin(done);
  // });

  // //TestFns.skipIf("odata", "does not support server interception or alt resources").
  // // skipIf("mongo", "has not yet implemented this").
  // test("with server side entity level validation error + repeat", function () {
  //   expect.hasAssertions();

  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);
  //   const cust1 = zzz.cust1;
  //   cust1.setProperty("companyName", "error");

  //   em.saveChanges().then(function (sr) {
  //     expect(false, "should not get here");
  //   }).catch(function (e) {
  //     expect(e.entityErrors, "should be a server error");
  //     expect(e.entityErrors.length).toBe(1, "should be only one server error");
  //     const errors = cust1.entityAspect.getValidationErrors();
  //     expect(errors.length).toBe(1, "should only be 1 error");
  //     expect(errors[0].errorMessage).toBe(e.entityErrors[0].errorMessage, "error message should appear on the cust");
  //     return em.saveChanges();
  //   }).catch(function (e2) {
  //     expect(e2.entityErrors, "should be a server error");
  //     expect(e2.entityErrors.length).toBe(1, "should be only one server error");
  //     const errors = cust1.entityAspect.getValidationErrors();
  //     expect(errors.length).toBe(1, "should only be 1 error");
  //     expect(errors[0].errorMessage).toBe(e2.entityErrors[0].errorMessage, "error message should appear on the cust");
  //   }).fin(done);
  // });


  // test("delete unsaved entity", function () {
  //   expect.hasAssertions();
  //   const realEm = TestFns.newEntityManager();
  //   expect(realEm.hasChanges()).toBe(false, "The entity manager must not have changes");
  //   const query = EntityQuery.from("Customers")
  //     .where(TestFns.customerKeyName, "==", "729de505-ea6d-4cdf-89f6-0360ad37bde7");

  //   const cust;
  //   realEm.executeQuery(query).then(function (data) {
  //     cust = data.results[0];
  //     return cust.entityAspect.loadNavigationProperty("orders");
  //   }).then(function (data2) {
  //     const newOrder = realEm.createEntity("Order", {}, breeze.EntityState.Detached);
  //     const orders = cust.getProperty("orders");
  //     orders.push(newOrder);
  //     expect(newOrder.entityAspect.entityState.isAdded()).toBe(true, "The entity is Added");
  //     newOrder.entityAspect.setDeleted();
  //     expect(realEm.hasChanges()).toBe(false, "The entity manager must not  have changes");
  //     return realEm.saveChanges();
  //   }).then(function (sr) {
  //     expect(realEm.hasChanges()).toBe(false, "The entity manager must not have changes");
  //   });
  // });

  // test("bigsave", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const recentArgs;
  //   em.hasChangesChanged.subscribe(function (args) {
  //     recentArgs = args;
  //   });
  //   for (const i = 0; i < 20; i++) {
  //     const zzz = createParentAndChildren(em);
  //   }
  //   expect(recentArgs.hasChanges).toBe(true);


  //   const startMs = Date.now();
  //   const endMs;
  //   em.saveChanges().then(function (sr) {
  //     const r = sr.entities;
  //     expect(r.length).toBe(80, "Length: " + r.length);
  //     endMs = Date.now();
  //     const elapsed = (endMs - startMs) / 1000;
  //     expect(elapsed, "Elapsed time: " + elapsed);
  //   });
  // });

  // test("bigsave many children", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const recentArgs;
  //   em.hasChangesChanged.subscribe(function (args) {
  //     recentArgs = args;
  //   });
  //   for (const i = 0; i < 5; i++) {
  //     const zzz = createParentAndManyChildren(em);
  //   }
  //   expect(recentArgs.hasChanges).toBe(true);


  //   const startMs = Date.now();
  //   const endMs;
  //   em.saveChanges().then(function (sr) {
  //     const r = sr.entities;
  //     expect(r.length > 100, "Length: " + r.length);
  //     endMs = Date.now();
  //     const elapsed = (endMs - startMs) / 1000;
  //     expect(elapsed, "Elapsed time: " + elapsed);
  //   });
  // });

  // test("noop", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const q = new EntityQuery("Customers");

  //   q.using(em).execute().then(function (data) {
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(Array.isArray(sr.entities));
  //     expect(sr.entities.length).toBe(0);
  //     expect(!em.hasChanges());
  //   });
  // });

  // //TestFns.skipIf("sequelize,hibernate", " is unsupported because MySQL does not support millisecond resolution").
  // test("data with millseconds - UTC time - IE bug", function () {
  //   expect.hasAssertions();


  //   const em = TestFns.newEntityManager();
  //   const dt = new Date(Date.parse("2012-12-17T13:35:15.690Z"));
  //   const offset = dt.getTimezoneOffset() * 60000;
  //   const dt1 = new Date(dt.getTime() - offset);
  //   const dt2 = new Date(dt.getTime() + offset);
  //   const ms = dt.getUTCMilliseconds();
  //   expect(ms).toBe(690);
  //   const q = new EntityQuery("Orders").where("shippedDate", "!=", dt).take(1);

  //   const order;
  //   q.using(em).execute().then(function (data) {
  //     order = data.results[0];
  //     order.setProperty("shippedDate", dt);
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(sr.entities.length).toBe(1, "should have saved one entity");
  //     const sameOrder = sr.entities[0];
  //     expect(order).toBe(sameOrder, "should be the sameOrder");
  //     const sameDt = sameOrder.getProperty("shippedDate");
  //     expect(dt.getTime()).toBe(sameDt.getTime(), "should be the same date");
  //     const em2 = TestFns.newEntityManager();
  //     const q2 = EntityQuery.fromEntities(order);
  //     return q2.using(em2).execute();
  //   }).then(function (data2) {
  //     const order2 = data2.results[0];
  //     const sameDt2 = order2.getProperty("shippedDate");
  //     expect(dt.getTime()).toBe(sameDt2.getTime(), "should be the same date: " + dt.toString() + ").not.toBe(" + sameDt2.toString());
  //   });
  // });

  // //TestFns.skipIf("sequelize,hibernate", " is unsupported because MySQL does not support millisecond resolution").
  // test("data with millseconds - local time", function () {
  //   expect.hasAssertions();

  //   const em = TestFns.newEntityManager();
  //   // Date.parse("2012-12-17T13:35:15.690");
  //   const dt = new Date(2012, 11, 17, 13, 35, 15, 690); // local time
  //   const ms = dt.getMilliseconds();
  //   expect(ms).toBe(690);
  //   const q = new EntityQuery("Orders").take(1);

  //   const order;
  //   q.using(em).execute().then(function (data) {
  //     order = data.results[0];
  //     order.setProperty("shippedDate", dt);
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(sr.entities.length).toBe(1, "should have saved one entity");
  //     const sameOrder = sr.entities[0];
  //     expect(order).toBe(sameOrder, "should be the sameOrder");
  //     const sameDt = sameOrder.getProperty("shippedDate");
  //     expect(dt.getTime()).toBe(sameDt.getTime(), "should be the same date");
  //     const em2 = TestFns.newEntityManager();
  //     const q2 = EntityQuery.fromEntities(order);
  //     return q2.using(em2).execute();
  //   }).then(function (data2) {
  //     const order2 = data2.results[0];
  //     const sameDt2 = order2.getProperty("shippedDate");
  //     expect(dt.getTime()).toBe(sameDt2.getTime(), "should be the same date: " + dt.toString() + ").not.toBe(" + sameDt2.toString());
  //   });
  // });

  // //TestFns.skipIf("sequelize,hibernate", " is unsupported because MySQL does not support millisecond resolution").
  // test("custom data annotation validation", function () {
  //   expect.hasAssertions();

  //   // This test will fail currently with the DATABASEFIRST_OLD define.
  //   // This is because ObjectContext.SaveChanges() does not automatically validate
  //   // entities. It must be done manually.
  //   const em = TestFns.newEntityManager();
  //   const q = new EntityQuery("Customers").skip(20).take(1).orderBy("contactName");

  //   const cust1;
  //   q.using(em).execute().then(function (data) {
  //     expect(data.results.length).toBe(1);
  //     cust1 = data.results[0];
  //     const region = cust1.getProperty("contactName");
  //     const newRegion = region == "Error" ? "Error again" : "Error";
  //     cust1.setProperty("contactName", newRegion);
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(false, "shouldn't get here - except with DATABASEFIRST_OLD");
  //   }).catch(function (error) {
  //     expect(error.entityErrors, "should be some server errors");
  //     expect(error.entityErrors.length).toBe(1, "should be 1 server error");
  //     expect(error.entityErrors[0].errorMessage.indexOf("the word 'Error'") > 0, "incorrect error message");
  //     const custErrors = cust1.entityAspect.getValidationErrors();
  //     expect(error.entityErrors[0].errorMessage).toBe(custErrors[0].errorMessage);
  //     // expect(error.message.indexOf("the word 'Error'") > 0, "incorrect error message");
  //   }).fin(done);
  // });

  // test("date", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const q = new EntityQuery("Orders").where("orderDate", '!=', null).take(10);

  //   const order, orderDate, newOrderDate;
  //   q.using(em).execute().then(function (data) {
  //     const r = data.results;
  //     expect(r.length > 0, "should be some results");
  //     order = r[0];
  //     orderDate = order.getProperty("orderDate");
  //     expect(core.isDate(orderDate), "is not a date");
  //     const day = orderDate.getDate();
  //     day = day < 31 ? day + 1 : 1;
  //     newOrderDate = new Date(orderDate.getTime());
  //     newOrderDate.setDate(day);
  //     expect(core.isDate(newOrderDate), "is not a date");
  //     order.setProperty("orderDate", newOrderDate);
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(Array.isArray(sr.entities));
  //     expect(sr.entities.length).toBe(1);
  //     expect(!em.hasChanges());
  //     expect(sr.entities[0]).toBe(order, "should be same order");
  //     const newOrderDate2 = order.getProperty("orderDate");
  //     expect(core.isDate(newOrderDate2), "is not a date");
  //     expect(newOrderDate.getTime()).toBe(newOrderDate2.getTime());
  //     expect(orderDate).not.toBe(newOrderDate2);
  //   });
  // });

  // test("unmapped", function () {
  //   expect.hasAssertions();

  //   // use a different metadata store for this em - so we don't polute other tests
  //   const em1 = TestFns.newEntityManager(TestFns.newMs());
  //   const Customer = TestFns.makeEntityCtor(function () {
  //     this.miscData = "asdf";
  //   });
  //   em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

  //   const q = new EntityQuery("Customers")
  //     .where("companyName", "startsWith", "C");
  //   q.using(em1).execute().then(function (data) {
  //     const customers = data.results;
  //     customers.every(function (c) {
  //       expect(c.getProperty("miscData")).toBe("asdf", "miscData should).toBe('asdf'");

  //     });
  //     const cust = customers[0];
  //     cust.setProperty("miscData", "xxx");
  //     expect(cust.entityAspect.entityState).toBe(EntityState.Unchanged);
  //     expect(!em1.hasChanges(), "should not have changes");
  //     return em1.saveChanges();
  //   }).then(function (sr) {
  //     const saved = sr.entities;
  //     expect(saved.length).toBe(0);
  //     expect(!em1.hasChanges());
  //   });
  // });

  // test("unmapped with ES5 props", function () {
  //   expect.hasAssertions();

  //   // use a different metadata store for this em - so we don't polute other tests
  //   const em1 = TestFns.newEntityManager(TestFns.newMs());
  //   const Customer = TestFns.models.CustomerWithES5Props();

  //   em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

  //   const q = new EntityQuery("Customers")
  //     .where("companyName", "startsWith", "C");
  //   q.using(em1).execute().then(function (data) {
  //     const customers = data.results;
  //     customers.every(function (c) {
  //       expect(c.getProperty("miscData")).toBe("asdf", "miscData should).toBe('asdf'");

  //     });
  //     const cust = customers[0];
  //     cust.setProperty("miscData", "xxx");
  //     expect(cust.entityAspect.entityState).toBe(EntityState.Unchanged);
  //     expect(!em1.hasChanges(), "should not have changes");
  //     return em1.saveChanges();
  //   }).then(function (sr) {
  //     const saved = sr.entities;
  //     expect(saved.length).toBe(0);
  //     expect(!em1.hasChanges());
  //   });
  // });

  // test("add parent and children", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const recentArgs;
  //   em.hasChangesChanged.subscribe(function (args) {
  //     recentArgs = args;
  //   });
  //   const zzz = createParentAndChildren(em);
  //   expect(recentArgs.hasChanges).toBe(true);

  //   em.saveChanges(null, null).then(function (saveResult) {
  //     expect(recentArgs.hasChanges).toBe(false);
  //     expect(zzz.cust1.entityAspect.entityState.isUnchanged());
  //     expect(zzz.cust2.entityAspect.entityState.isUnchanged());
  //     expect(zzz.order1.entityAspect.entityState.isUnchanged());
  //     expect(zzz.order2.entityAspect.entityState.isUnchanged());
  //     expect(zzz.cust1.getProperty(TestFns.customerKeyName)).not.toBe(zzz.keyValues[0], "cust1.customerID should not match original values");
  //     expect(zzz.cust2.getProperty(TestFns.customerKeyName)).not.toBe(zzz.keyValues[1], "cust2.customerID should not match original values");
  //     expect(zzz.order1.getProperty(TestFns.orderKeyName)).not.toBe(zzz.keyValues[2]);
  //     expect(zzz.order2.getProperty(TestFns.orderKeyName)).not.toBe(zzz.keyValues[3]);
  //     expect(zzz.order1.getProperty("customer")).toBe(zzz.cust1);
  //     expect(zzz.order2.getProperty("customer")).toBe(zzz.cust1);
  //     expect(zzz.cust1.getProperty("orders").length).toBe(2);
  //     expect(zzz.cust2.getProperty("orders").length).toBe(0);
  //     expect(!em.hasChanges());
  //   });
  // });

  // test("allow concurrent saves with concurrency column", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
  //   const q = new EntityQuery()
  //     .from("Customers")
  //     .take(2);


  //   return em.executeQuery(q).then(function (data) {
  //     // query cust
  //     const cust = data.results[0];
  //     TestFns.morphStringProp(cust, "companyName");

  //     return Promise.all([em.saveChanges(), em.saveChanges()]);
  //   }).then(function (x) {
  //     expect(false, "one save should have failed for concurrency reasons");
  //   }).catch(function (e) {
  //     const msg = e.message;
  //     if (msg.indexOf("Data may have been modified or") >= 0) {
  //       expect(true, "got expected (EFCore) exception " + msg);
  //     } else if (msg.indexOf("Store update, insert") >= 0) {
  //       expect(true, "got expected (EF) exception " + msg);
  //     } else if (msg.indexOf("Row was updated or deleted by another transaction") >= 0) {
  //       expect(true, "got expected (Hibernate) exception " + msg);
  //     } else if (msg.indexOf("concurrency check") >= 0) {
  //       expect(true, "got expected (Mongo) exception " + msg);
  //     } else if (msg.indexOf("concurrency violation") >= 0) {
  //       expect(true, "got expected (Sequelize) exception " + msg);
  //     } else {
  //       expect(false, msg);
  //     }
  //   }).fin(done);

  // });

  // test("allow concurrent saves with NO concurrency column", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
  //   const q = new EntityQuery()
  //     .from("Products")
  //     .take(2);


  //   const prod;

  //   return em.executeQuery(q).then(function (data) {
  //     // query cust
  //     prod = data.results[0];
  //     const price = prod.getProperty("unitPrice");
  //     prod.setProperty("unitPrice", price + .01);

  //     return Promise.all([em.saveChanges(), em.saveChanges()]);
  //   }).then(function (x) {
  //     expect(true, "expected both to succeed");
  //   }).catch(function (e) {
  //     expect(false, "both saves should have been ok but: " + e.message);
  //   }).fin(done);

  // });

  // test("disallow concurrent saves with NO concurrency column", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   // Next line is not needed because it is the default
  //   // em.saveOptions = new SaveOptions({ allowConcurrentSaves: false });
  //   const q = new EntityQuery()
  //     .from("Products")
  //     .take(2);


  //   const prod;

  //   return em.executeQuery(q).then(function (data) {
  //     // query cust
  //     prod = data.results[0];
  //     const price = prod.getProperty("unitPrice");
  //     prod.setProperty("unitPrice", price + .01);

  //     return Promise.all([em.saveChanges(), em.saveChanges()]);
  //   }).then(function (x) {
  //     expect(false, "expected only one to complete");
  //   }).catch(function (e) {
  //     if (e.message.indexOf("allowConcurrentSaves") >= 0) {
  //       expect(true, "got expected error: " + e.message);
  //     } else {
  //       expect(false, "unexpected error: " + e.message);
  //     }
  //   }).fin(done);

  // });

  // test("modify one", async function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const query = new EntityQuery()
  //     .from("Customers")
  //     .where("companyName", "startsWith", "C")
  //     .take(2);

  //   const newCompanyName, cust;
  //   const data = await em.executeQuery(query);
  //   cust = data.results[0];
  //   const orders = cust.getProperty("orders");
  //   const companyName = cust.getProperty("companyName");
  //   newCompanyName = TestFns.morphString(companyName);
  //   cust.setProperty("companyName", newCompanyName);
  //   const saveResult = await em.saveChanges();
  //   expect(!em.hasChanges());
  //   const entities = saveResult.entities;
  //   expect(entities.length).toBe(1);
  //   expect(saveResult.keyMappings.length).toBe(0);
  //   expect(entities[0]).toBe(cust);
  //   expect(cust.getProperty("companyName")).toBe(newCompanyName);
  //   expect(cust.entityAspect.entityState.isUnchanged());
  //   const q2 = EntityQuery.fromEntities(cust);
  //   const data2 = await em.executeQuery(q2);
  //   const entities2 = data2.results;
  //   expect(entities2.length).toBe(1);
  //   expect(entities2[0]).toBe(cust);
  //   expect(cust.getProperty("companyName")).toBe(newCompanyName);
  // });

  // test("modify parent and children", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();

  //   const cust, orders, newCompanyName;
  //   saveNewCustAndOrders(em).then(function (savedCust) {
  //     cust = savedCust;
  //     if (cust == null) {
  //       throw new Error("Test error - need a customer with orders");
  //     }
  //     const companyName = cust.getProperty("companyName");
  //     newCompanyName = TestFns.morphStringProp(cust, "companyName");
  //     expect(cust.entityAspect.entityState.isModified(), "should be modified");
  //     orders = cust.getProperty("orders");
  //     orders.forEach(function (o) {
  //       TestFns.morphStringProp(o, "shipName");
  //       expect(o.entityAspect.entityState.isModified(), "should be modified");
  //     });
  //     return em.saveChanges();
  //   }).then(function (saveResult) {
  //     expect(!em.hasChanges());
  //     const entities = saveResult.entities;
  //     expect(entities.length).toBe(1 + orders.length, "wrong number of entities returned");
  //     expect(saveResult.keyMappings.length).toBe(0, "no key mappings should be returned");

  //     entities.forEach(function (e) {
  //       expect(e.entityAspect.entityState.isUnchanged(), "entity is not in unchanged state");
  //       if (e.entityType).toBe(cust.entityType) {
  //         expect(e).toBe(cust, "cust does not match");
  //       } else {
  //         expect(orders.indexOf(e) >= 0, "order does not match");
  //       }
  //     });

  //     expect(cust.getProperty("companyName")).toBe(newCompanyName, "company name was not changed");
  //     expect(cust.entityAspect.entityState.isUnchanged(), "entityState should be unchanged");
  //     const q2 = EntityQuery.fromEntities(cust);

  //     return em.executeQuery(q2);
  //   }).then(function (data2) {
  //     const entities2 = data2.results;
  //     expect(entities2.length).toBe(1, "should only get a single entity");
  //     expect(entities2[0]).toBe(cust, "requery does not match cust");
  //     expect(cust.getProperty("companyName")).toBe(newCompanyName, "company name was not changed on requery");
  //   });
  // });



  // test("delete parent, children stranded", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   em.saveChanges().then(function (saveResult) {
  //     zzz.cust1.entityAspect.setDeleted();
  //     const order1custid = zzz.order1.getProperty("customerID");
  //     expect(order1custid).toBe(null, "cust id should have been null'd");
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(true, "saved ok - children null'd");
  //     // this can occur if we have a foreign key constraint on customer.orders
  //     //}).catch(function (error) {
  //     //expect(em.hasChanges());
  //     //expect(error instanceof Error, "should be an error");
  //     //expect(error.message.indexOf("FOREIGN KEY") >= 0, "message should contain 'FOREIGN KEY'");
  //     //});
  //   });
  // });

  // test("delete parent, then clear", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   em.saveChanges().then(function (saveResult) {
  //     expect(!em.hasChanges());
  //     zzz.cust1.entityAspect.setDeleted();
  //     zzz.order1.entityAspect.setDeleted();
  //     zzz.order2.entityAspect.setDeleted();
  //     expect(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(em.hasChanges());
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     try {
  //       em.clear();

  //     } catch (e) {
  //       expect(false, "clear should not fail: " + e);
  //     }
  //   });
  // });

  // test("delete parent then delete children", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   em.saveChanges().then(function (saveResult) {
  //     expect(!em.hasChanges());
  //     zzz.cust1.entityAspect.setDeleted();
  //     zzz.order1.entityAspect.setDeleted();
  //     zzz.order2.entityAspect.setDeleted();
  //     expect(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(em.hasChanges());
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(!em.hasChanges());
  //     expect(sr.entities.length).toBe(3, "should be 3 entities saved");
  //     expect(zzz.order1.entityAspect.entityState.isDetached(), "order1 should be marked as detached");
  //     expect(zzz.order2.entityAspect.entityState.isDetached(), "order2 should be marked as detached");
  //     expect(zzz.cust1.entityAspect.entityState.isDetached(), "cust1 should be marked as detached");
  //   });
  // });

  // test("delete children then delete parent", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   em.saveChanges().then(function (saveResult) {
  //     const orders = zzz.cust1.getProperty("orders");
  //     expect(zzz.order1).toBe(orders[0]);
  //     const cust1a = zzz.order1.getProperty("customer");
  //     expect(cust1a).toBe(zzz.cust1);


  //     zzz.order1.entityAspect.setDeleted();
  //     zzz.order2.entityAspect.setDeleted();
  //     zzz.cust1.entityAspect.setDeleted();
  //     expect(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(!em.hasChanges());
  //     expect(sr.entities.length).toBe(3, "should be 3 entities saved");
  //     expect(zzz.order1.entityAspect.entityState.isDetached(), "order1 should be marked as detached");
  //     expect(zzz.order2.entityAspect.entityState.isDetached(), "order2 should be marked as detached");
  //     expect(zzz.cust1.entityAspect.entityState.isDetached(), "cust1 should be marked as detached");
  //   });
  // });

  // test("delete children then delete parent after query", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const em2 = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   const cust;
  //   em.saveChanges().then(function (saveResult) {
  //     const q = EntityQuery.fromEntities(zzz.cust1);
  //     q = EntityQuery.from("Customers").where(q.wherePredicate);
  //     return em2.executeQuery(q);
  //   }).then(function (data) {
  //     // this step is to avoid having to do an expand above - allows this test to be used for Mongo as well.
  //     cust = data.results[0];
  //     return cust.entityAspect.loadNavigationProperty("orders");
  //   }).then(function (data2) {
  //     const orders = cust.getProperty("orders").slice(0);
  //     orders.forEach(function (o) {
  //       o.entityAspect.setDeleted();
  //     });
  //     cust.entityAspect.setDeleted();
  //     expect(orders[0].entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(cust.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     return em2.saveChanges();
  //   }).then(function (sr) {
  //     expect(!em2.hasChanges(), "em should have no changes");
  //     expect(sr.entities.length).toBe(3, "should be 3 entities saved");
  //     sr.entities.forEach(function (e) {
  //       expect(e.entityAspect.entityState.isDetached(), "entity should be marked as detached");
  //     });
  //   });
  // });

  // test("delete children, leave parent alone", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   em.saveChanges().then(function (saveResult) {
  //     zzz.order1.entityAspect.setDeleted();
  //     expect(zzz.cust1.getProperty("orders").length).toBe(1, "should only be 1 order now");
  //     zzz.order2.entityAspect.setDeleted();
  //     expect(zzz.cust1.getProperty("orders").length).toBe(0, "should be no orders now");
  //     expect(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     expect(zzz.cust1.entityAspect.entityState.isUnchanged(), "should be unchanged");
  //     return em.saveChanges();
  //   }).then(function (sr) {
  //     expect(!em.hasChanges());
  //     expect(zzz.order1.entityAspect.entityState.isDetached(), "should be marked as detached");
  //     expect(zzz.cust1.getProperty("orders").length).toBe(0, "should be no orders now");
  //   });
  // });

  // test("delete parent, move children", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const zzz = createParentAndChildren(em);

  //   em.saveChanges().then(function (saveResult) {
  //     zzz.cust1.entityAspect.setDeleted();
  //     zzz.order1.setProperty("customer", zzz.cust2);
  //     expect(zzz.order1.entityAspect.entityState.isModified(), "should be marked as modified");
  //     zzz.order2.setProperty("customer", zzz.cust2);
  //     expect(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
  //     return em.saveChanges();
  //   }).then(function (sr2) {
  //     expect(!em.hasChanges());
  //     expect(sr2.entities.length).toBe(3);
  //     expect(zzz.cust1.entityAspect.entityState.isDetached(), "should be marked as detached");
  //     expect(zzz.order1.entityAspect.entityState.isUnchanged(), "should be marked as unchanged");
  //   });
  // });

  // test("concurrency violation", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const em2 = TestFns.newEntityManager();
  //   const q = new EntityQuery()
  //     .from("Customers")
  //     .take(2);


  //   const cust;
  //   const sameCust;
  //   return em.executeQuery(q).then(function (data) {
  //     // query cust
  //     cust = data.results[0];
  //     const q2 = EntityQuery.fromEntities(cust);
  //     return em2.executeQuery(q2);
  //   }).then(function (data2) {
  //     // query same cust in dif em
  //     // and modify it and resave it
  //     expect(data2.results.length).toBe(1, "should only have 1 result");
  //     sameCust = data2.results[0];
  //     expect(cust.entityAspect.getKey().equals(sameCust.entityAspect.getKey()), "should be the same key");
  //     TestFns.morphStringProp(sameCust, "companyName");
  //     return em2.saveChanges();
  //   }).then(function (sr2) {
  //     TestFns.morphStringProp(cust, "companyName");
  //     return em.saveChanges();
  //   }).then(function (sr2) {
  //     expect(false, "should not get here, save should have failed");
  //   }).catch(function (error) {
  //     expect(em.hasChanges(), "entityManager should still have changes pending after a save failure");
  //     const exceptionType = error.detail.ExceptionType.toLowerCase();
  //     expect((exceptionType.indexOf("concurrency") >= 0 || exceptionType.indexOf("staleobjectstate") >= 0), "wrong error message: " + error.detail.ExceptionType);
  //   }).fin(done);
  // });


  // //test("concurrency violation on delete", function() {
  // //    expect.hasAssertions();
  // //    expect(false, "not yet implemented");
  // //});

  // test("insert of existing entity", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   // need to use a resource that does NOT do autoGeneratedKeys
  //   const resourceName = TestFns.DEBUG_MONGO ? "Products" : "OrderDetails";
  //   const q = new EntityQuery()
  //     .from(resourceName)
  //     .take(2);


  //   const em2;
  //   return em.executeQuery(q).then(function (data) {
  //     const o = data.results[0];
  //     em.detachEntity(o);
  //     em2 = TestFns.newEntityManager();
  //     em2.addEntity(o);
  //     return em2.saveChanges();
  //   }).then(function (sr) {
  //     expect(false, "shouldn't get here");
  //   }).catch(function (error) {
  //     expect(em2.hasChanges());
  //     const frag;
  //     if (TestFns.DEBUG_MONGO) {
  //       frag = "duplicate key error"
  //     } else if (TestFns.DEBUG_SEQUELIZE) {
  //       frag = "SequelizeUniqueConstraintError".toLowerCase();
  //     } else if (TestFns.DEBUG_HIBERNATE) {
  //       frag = "duplicate entry"
  //     } else {
  //       frag = "primary key constraint"
  //     }
  //     expect(error.message.toLowerCase().indexOf(frag) >= 0, "wrong error message: " + error.message);
  //   }).fin(done);
  // });

  // //TestFns.skipIf("mongo,hibernate,sequelize", "does not have a TimeGroup table").
  // // skipIf("odata", "does not support this feature").
  // test("insert using existing entity re-attached", async function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const q = new EntityQuery()
  //     .from("TimeGroups")
  //     .take(2);
  //   const tg = "test";

  //   const data = await em.executeQuery(q);
  //   if (data.results.length == 0) {
  //     tg = em.createEntity("TimeGroup", { comment: "trigger" });
  //   }
  //   else {
  //     tg = data.results[0];
  //     TestFns.morphStringProp(tg, "comment");
  //   }
  //   const sr = await em.saveChanges();
  //   const tg1 = sr.entities[0];
  //   expect(tg1).toBe(tg, "should be the same");
  //   em.detachEntity(tg);
  //   tg.Id = -1;
  //   em.attachEntity(tg, breeze.EntityState.Added);
  //   tg.setProperty("comment", "This was re-attached");
  //   const sr2 = await em.saveChanges();
  //   expect(true, "save successful");
  // });

  // //TestFns.skipIf("odata", "does not support custom server side key generation").
  // test("insert with generated key", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();

  //   const region1 = createRegion(em, "1");
  //   const k1 = region1.entityAspect.getKey();

  //   const region2 = createRegion(em, "2");
  //   const k2 = region2.entityAspect.getKey();


  //   em.saveChanges().then(function (data) {
  //     expect(!em.hasChanges());
  //     expect(data.entities.length).toBe(2);
  //     expect(!region1.entityAspect.getKey().equals(k1));
  //     expect(!region2.entityAspect.getKey().equals(k2));
  //     return data;
  //   }).then(function (data2) {
  //     // curious about synchronous results
  //     expect(data2.entities.length).toBe(2);
  //   });
  // });

  // //TestFns.skipIf("odata", "does not support custom server side key generation").
  // test("insert uni (1-n) relationships with generated key", function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();

  //   const region1 = createRegion(em, "1");
  //   const k1 = region1.entityAspect.getKey();
  //   const terrs1 = region1.getProperty("territories");
  //   const terr1a = createTerritory(em, "test 1a");
  //   const terr1b = createTerritory(em, "test 1b");
  //   terrs1.push(terr1a);
  //   terrs1.push(terr1b);

  //   const region2 = createRegion(em, "2");
  //   const k2 = region2.entityAspect.getKey();
  //   const terrs2 = region2.getProperty("territories");
  //   const terr2a = createTerritory(em, "test 2a");
  //   const terr2b = createTerritory(em, "test 2b");
  //   terrs2.push(terr2a);
  //   terrs2.push(terr2b);

  //   expect(region1.getProperty("territories").length).toBe(2, "should have two terrs");
  //   expect(region2.getProperty("territories").length).toBe(2, "should have two terrs");


  //   const terrs1x, terrs2x, region1y, terrs1y;
  //   const em2 = TestFns.newEntityManager();
  //   em.saveChanges().then(function (data) {
  //     expect(!em.hasChanges());

  //     expect(data.entities.length).toBe(6);
  //     expect(!region1.entityAspect.getKey().equals(k1));
  //     terrs1x = region1.getProperty("territories");
  //     expect(terrs1x).toBe(terrs1, "territories should be the same");
  //     expect(terrs1x.length).toBe(2, "terrs1 - length should be 2");
  //     expect(!region2.entityAspect.getKey().equals(k2));
  //     terrs2x = region2.getProperty("territories");
  //     expect(terrs2x).toBe(terrs2, "territories should be the same");
  //     expect(terrs2x.length).toBe(2, "terrs2 - length should be 2");
  //     expect(terrs2x[0].getProperty("regionID")).toBe(region2.getProperty(TestFns.regionKeyName), "regionId should have been updated");
  //     // now move them all onto region1;
  //     terrs2x.slice(0).forEach(function (t) {
  //       t.setProperty("regionID", region1.getProperty(TestFns.regionKeyName));
  //     });
  //     expect(terrs1x.length).toBe(4, "terrs1x should now be length 4");
  //     expect(terrs2x.length).toBe(0, "terrs2x should now be length 0");
  //     return em.saveChanges();
  //   }).then(function (sr2) {
  //     expect(sr2.entities.length).toBe(2, "should have saved 2 recs");
  //     expect(terrs1x.length).toBe(4, "terrs1x should now be length 4");
  //     expect(terrs2x.length).toBe(0, "terrs2x should now be length 0");
  //     return EntityQuery.fromEntities(region1).using(em2).execute();
  //   }).then(function (data3) {
  //     region1y = data3.results[0];
  //     terrs1y = region1y.getProperty("territories");
  //     return terrs1y.load();
  //   }).then(function (data4) {
  //     expect(data4.results.length).toBe(4, "should be 4 terrs");
  //     expect(terrs1y.length).toBe(4, "terrs1y should be of length 4");

  //   });
  // });

  // //TestFns.skipIf("odata", "does not support custom server side key generation").
  // // skipIf("mongo", "does not support 'expand'").
  // test("insert uni (1-n) relationships with generated key - v2", function () {
  //   expect.hasAssertions();

  //   const em = TestFns.newEntityManager();
  //   const em2 = TestFns.newEntityManager();

  //   const region1 = createRegion(em, "1");
  //   const k1 = region1.entityAspect.getKey();
  //   const terrs1 = region1.getProperty("territories");
  //   const terr1a = createTerritory(em, "test 1a");
  //   const terr1b = createTerritory(em, "test 1b");
  //   terr1a.setProperty("regionID", region1.getProperty(TestFns.regionKeyName));
  //   terr1b.setProperty("regionID", region1.getProperty(TestFns.regionKeyName));

  //   const region2 = createRegion(em, "2");
  //   const k2 = region2.entityAspect.getKey();
  //   const terrs2 = region2.getProperty("territories");
  //   const terr2a = createTerritory(em, "test 2a");
  //   const terr2b = createTerritory(em, "test 2b");
  //   terr2a.setProperty("regionID", region2.getProperty(TestFns.regionKeyName));
  //   terr2b.setProperty("regionID", region2.getProperty(TestFns.regionKeyName));

  //   expect(region1.getProperty("territories").length).toBe(2, "should have two terrs");
  //   expect(region2.getProperty("territories").length).toBe(2, "should have two terrs");

  //   const terrs1x, terrs2x, region1ID, region1y, terrs1y;


  //   em.saveChanges().then(function (data) {
  //     expect(!em.hasChanges());
  //     expect(data.entities.length).toBe(6);
  //     expect(!region1.entityAspect.getKey().equals(k1));
  //     terrs1x = region1.getProperty("territories");
  //     expect(terrs1x).toBe(terrs1, "territories should be the same");
  //     expect(terrs1x.length).toBe(2, "terrs1 - length should be 2");
  //     expect(!region2.entityAspect.getKey().equals(k2));
  //     terrs2x = region2.getProperty("territories");
  //     expect(terrs2x).toBe(terrs2, "territories should be the same");
  //     expect(terrs2x.length).toBe(2, "terrs2 - length should be 2");
  //     expect(terrs2x[0].getProperty("regionID")).toBe(region2.getProperty(TestFns.regionKeyName), "regionId should have been updated");
  //     // now move them all onto region1;
  //     terrs2x.slice(0).forEach(function (t) {
  //       terrs1x.push(t);
  //     });
  //     expect(terrs1x.length).toBe(4, "terrs1x should now be length 4");
  //     expect(terrs2x.length).toBe(0, "terrs2x should now be length 0");
  //     return em.saveChanges();
  //   }).then(function (sr2) {
  //     expect(sr2.entities.length).toBe(2, "should have saved 2 recs");
  //     expect(terrs1x.length).toBe(4, "terrs1x should now be length 4");
  //     expect(terrs2x.length).toBe(0, "terrs2x should now be length 0");
  //     return EntityQuery.fromEntities(region1).expand("territories").using(em).execute();
  //   }).then(function (data3) {
  //     expect(data3.results.length).toBe(1, "should be 1 region");
  //     expect(region1).toBe(data3.results[0], "should be same region");
  //     expect(terrs1x.length).toBe(4, "terrs1x should be of length 4");
  //     return EntityQuery.fromEntities(region1).expand("territories").using(em2).execute();
  //   }).then(function (data4) {
  //     expect(data4.results.length).toBe(1, "should be 1 region");
  //     terrs1y = data4.results[0].getProperty("territories");
  //     expect(terrs1y.length).toBe(4, "should still be 4 recs");
  //   });
  // });

  // //TestFns.skipIf("odata", "does not support custom server side key generation (except identity)").
  // test("insert uni (1-n) relationships with unattached children - v3", function () {
  //   expect.hasAssertions();

  //   const em = TestFns.newEntityManager();
  //   const em2 = TestFns.newEntityManager();

  //   const region1 = createRegion(em, "1");
  //   const k1 = region1.entityAspect.getKey();
  //   const terrs1 = region1.getProperty("territories");
  //   const terr1a = createTerritory(em, "test 1a");
  //   const terr1b = createTerritory(em, "test 1b");
  //   terr1a.setProperty("regionID", region1.getProperty(TestFns.regionKeyName));
  //   terr1b.setProperty("regionID", region1.getProperty(TestFns.regionKeyName));

  //   const region2 = createRegion(em, "2");
  //   const k2 = region2.entityAspect.getKey();
  //   const terrs2 = region2.getProperty("territories");
  //   const terr2a = createTerritory(em, "test 2a");
  //   const terr2b = createTerritory(em, "test 2b");
  //   terr2a.setProperty("regionID", region2.getProperty(TestFns.regionKeyName));
  //   terr2b.setProperty("regionID", region2.getProperty(TestFns.regionKeyName));

  //   expect(region1.getProperty("territories").length).toBe(2, "should have two terrs");
  //   expect(region2.getProperty("territories").length).toBe(2, "should have two terrs");
  //   const terrs1x, terrs2x, region1ID, region1y, terrs1y;



  //   em.saveChanges().then(function (data) {
  //     expect(!em.hasChanges());
  //     expect(data.entities.length).toBe(6);
  //     expect(!region1.entityAspect.getKey().equals(k1));
  //     const territories = em.getEntities("Territory");
  //     return EntityQuery.fromEntities(territories).using(em2).execute();
  //   }).then(function (data2) {
  //     expect(data2.results.length).toBe(4, "should be 4 recs");
  //     return EntityQuery.fromEntities(region1).using(em2).execute();
  //   }).then(function (data3) {
  //     expect(data3.results.length).toBe(1, "should be 1 rec");
  //     const region1a = data3.results[0];
  //     const terrs1a = region1a.getProperty("territories");
  //     expect(terrs1a.length).toBe(2, "should be 2 terrs in region1");
  //   });
  // });

  // test("save of deleted entity should not trigger validation", function () {
  //   expect.hasAssertions();
  //   // TODO: OData bug here is because of region - AutoGeneratedKeyType
  //   const em = TestFns.newEntityManager();
  //   const cust = createCustomer(em);

  //   expect(em.hasChanges());
  //   em.saveChanges().then(function (sr) {
  //     expect(!em.hasChanges());
  //     expect(sr.entities.length).toBe(1, "one entity should have been saved");
  //     expect(sr.entities[0]).toBe(cust, "save result should contain cust");
  //     cust.setProperty("companyName", "");
  //     cust.entityAspect.setDeleted();
  //     expect(em.hasChanges());
  //     return em.saveChanges();
  //   }).then(function (sr2) {
  //     expect(!em.hasChanges());
  //     expect(sr2.entities.length).toBe(1, "one entity should have been saved");
  //     expect(sr2.entities[0]).toBe(cust, "save result should contain region");
  //     expect(cust.entityAspect.entityState.isDetached(), "cust should now be detached");
  //   });
  // });

  // test("bad save call", function () {
  //   const em = TestFns.newEntityManager();
  //   try {
  //     em.saveChanges(null, new SaveOptions(), "adfa");
  //   } catch (e) {
  //     expect(e.message.indexOf("callback") >= 0);
  //   }
  //   try {
  //     em.saveChanges(null, "adfa");
  //   } catch (e) {
  //     expect(e.message.indexOf("saveOptions") >= 0);
  //   }
  //   try {
  //     em.saveChanges("adfa");
  //   } catch (e) {
  //     expect(e.message.indexOf("entities") >= 0);
  //   }

  // });

  // //TestFns.skipIf("mongo", "does not support 'expand'").
  // test("cleanup  test data", async function () {
  //   expect.hasAssertions();
  //   const em = TestFns.newEntityManager();
  //   const p = breeze.Predicate.create("companyName", FilterQueryOp.StartsWith, "Test")
  //     .or("companyName", FilterQueryOp.StartsWith, "foo");
  //   const q = EntityQuery.from("Customers").where(p).expand("orders"); // .take(50);

  //   const data = await em.executeQuery(q);
  //   // const promises = [];
  //   em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
  //   data.results.forEach(function (cust) {
  //     const orders = cust.getProperty("orders").slice(0);
  //     orders.forEach(function (order) {
  //       //const details = order.getProperty("orderDetails");
  //       //details.forEach(function (detail) {
  //       //    detail.entityAspect.setDeleted();
  //       //});
  //       //const io = order.getProperty("internationalOrder");
  //       //if (io) {
  //       //    io.entityAspect.setDeleted();
  //       //}
  //       order.entityAspect.setDeleted();
  //     });
  //     cust.entityAspect.setDeleted();
  //     //const pr = em.saveChanges();
  //     //promises.push(pr);
  //   });
  //   const sr = await em.saveChanges();
  //   expect(sr.entities.length, "deleted count:" + sr.entities.length);
  // });

  function getWierdCustomerCtor() {
    const ctor =  function () {
      this.myUnmappedProperty = "anything22";
      const x: JsonObj = {
        x: "22",
        y: "test",
        z: ["a1", 3, true, null, undefined, { foo: 4 }, function (x: any, y: any, z: any) {
          return 666;
        }],
        testFn: function (a: any, b: any) {
          return a + b;
        }
      };
      x.recursive = { ok: true, notOk: x }; // notOk should not get serialized.
      this.anotherOne = x;
    };
    return ctor;
  }

  function createCustomer(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    return cust1;
  }

  async function saveNewCustAndOrders(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const orderType = metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    const order1 = orderType.createEntity();
    order1.setProperty("orderDate", new Date());
    const order2 = orderType.createEntity();
    const orders = cust1.getProperty("orders");
    order2.setProperty("orderDate", new Date());
    orders.push(order1);
    orders.push(order2);
    const sr1 = await em.saveChanges();
    expect(cust1.entityAspect.entityState.isUnchanged());
    return cust1;
  }

  function createParentAndChildren(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const orderType = metadataStore.getAsEntityType("Order");
    const orderKeyName = TestFns.wellKnownData.keyNames.order;
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    const cust2 = custType.createEntity();
    cust2.setProperty("companyName", "Test_js_2");
    cust2.setProperty("city", "Emeryville");
    cust2.setProperty("rowVersion", 1);
    cust2.setProperty("fax", "510 888-8888");
    em.addEntity(cust1);
    em.addEntity(cust2);
    const order1 = orderType.createEntity();
    order1.setProperty("orderDate", new Date());
    const order2 = orderType.createEntity();
    const orders = cust1.getProperty("orders");
    order2.setProperty("orderDate", new Date());
    orders.push(order1);
    orders.push(order2);
    const keyValues = [cust1.getProperty(customerKeyName),
    cust2.getProperty(customerKeyName),
    order1.getProperty(orderKeyName),
    order2.getProperty(orderKeyName)];
    return {
      cust1: cust1,
      cust2: cust2,
      order1: order1,
      order2: order2,
      keyValues: keyValues
    };
  }

  function createParentAndManyChildren(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const orderType = metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    const orders = cust1.getProperty("orders");
    for (let i = 1; i < 50; i++) {
      const order1 = orderType.createEntity();
      order1.setProperty("shipRegion", "foo-region");
      orders.push(order1);
    }
  }

  function createOrder(em: EntityManager) {
    const orderType = em.metadataStore.getAsEntityType("Order");
    const order = orderType.createEntity();
    em.addEntity(order);
    order.setProperty("shipName", "Test_" + new Date().toDateString());
    return order;
  }

  function createProduct(em: EntityManager) {
    const productType = em.metadataStore.getAsEntityType("Product");
    const product = productType.createEntity();
    em.addEntity(product);
    product.setProperty("productName", "Test_" + new Date().toDateString());
    return product;
  }

  function createOrderDetail(em: EntityManager, order: Entity, product: Entity) {
    const odType = em.metadataStore.getAsEntityType("OrderDetail");
    const od = odType.createEntity();
    const orderID = order.getProperty("orderID");
    const productID = product.getProperty("productID");

    od.setProperty("orderID", orderID);
    od.setProperty("productID", productID);
    od.setProperty("quantity", 1);
    od.setProperty("unitPrice", 3.14);
    em.addEntity(od);
    return od;
  }

  function createRegion(em: EntityManager, descr: string) {
    const regionType = em.metadataStore.getAsEntityType("Region");
    const region = regionType.createEntity();

    region.setProperty("regionDescription", "Test-" + descr + "-" + new Date().toDateString());
    em.addEntity(region);
    return region;
  }

  function createTerritory(em: EntityManager, descr: string) {
    const territoryType = em.metadataStore.getAsEntityType("Territory");
    const territory = territoryType.createEntity();
    territory.setProperty("territoryDescription", "Test-" + descr + "-" + new Date().toDateString());
    em.addEntity(territory);
    return territory;
  }

  function metadataSetup() {
    const regionType = TestFns.defaultMetadataStore.getAsEntityType("Region");
    regionType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
    const territoryType = TestFns.defaultMetadataStore.getEntityType("Territory");
    territoryType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
  }
});
