import { Entity, EntityQuery, EntityType, MetadataStore, Predicate, breeze, MergeStrategy, DataProperty, NavigationProperty, core, QueryOptions, EntityManager, EntityKey, RelationArray, FetchStrategy } from 'breeze-client';
import { TestFns, skipTestIf, skipDescribeIf } from './test-fns';

// function ok(a: any, b?: any) {
//   throw new Error('for test conversion purposes');
// }

TestFns.initServerEnv();

const exportImportSample1 = require('./support/export-import-1.json');

beforeAll(async () => {
  await TestFns.initDefaultMetadataStore();

});

describe("EntityManager import/export", () => {

  test("export/import with tempkey", function () {
    const DT = breeze.DataType;
    const newMs = new MetadataStore();
    initializeMetadataStore(newMs);
    const em1 = new EntityManager({ metadataStore: newMs });
    const emp1 = em1.createEntity("Employee");
    expect(emp1.entityAspect.hasTempKey).toBe(true);
    let exportedEnts = em1.exportEntities();

    DT._resetConstants();
    const em2 = new EntityManager();
    const r2 = em2.importEntities(exportedEnts);
    expect(r2.entities.every(r => r.entityAspect.hasTempKey)).toBe(true);

    const emp2 = em2.createEntity("Employee");
    expect(emp2.entityAspect.hasTempKey).toBe(true);
    exportedEnts = em2.exportEntities();

    DT._resetConstants();
    const em3 = new EntityManager();
    const r3 = em3.importEntities(exportedEnts);
    expect(r3.entities.every(r => r.entityAspect.hasTempKey));
    const emp3 = em3.createEntity("Employee");
    expect(emp3.entityAspect.hasTempKey).toBe(true);
    expect(em3.getEntities().length).toBe(3);
  });

  function initializeMetadataStore(metadataStore: MetadataStore) {
    const DT = breeze.DataType;

    metadataStore.addEntityType({
      shortName: "Employee",
      namespace: "Context",
      autoGeneratedKeyType: breeze.AutoGeneratedKeyType.Identity,
      dataProperties: {
        id: {
          dataType: DT.Int64,
          isPartOfKey: true
        },
        name: {
          dataType: DT.String
        }
      }
    });
    metadataStore.setEntityTypeForResourceName('Employee', 'Employee');
  }

  test("export/import with nulls", async function () {
    expect.hasAssertions();
    const queryOptions = new QueryOptions({
      mergeStrategy: MergeStrategy.OverwriteChanges,
      fetchStrategy: FetchStrategy.FromServer
    });
    const em = TestFns.newEntityManager()
    const pred = new breeze.Predicate("companyName", "!=", null).and("city", "!=", null);
    const q = EntityQuery.from("Customers").where(pred).take(2)
      .using(MergeStrategy.OverwriteChanges);
    const qr1 = await em.executeQuery(q);
    const custs = qr1.results;
    custs[0].setProperty("companyName", null);
    custs[1].setProperty("city", null);
    //exported = em.exportEntities(null, {includeMetadata: false});
    // use the deprecated syntax to exclude metadata
    const exported = em.exportEntities(null, false);
    const em2 = TestFns.newEntityManager();
    em2.importEntities(exported);
    const cust0x = em2.findEntityByKey(custs[0].entityAspect.getKey());
    expect(cust0x.getProperty("companyName")).toBeNull();
    const cust1x = em2.findEntityByKey(custs[1].entityAspect.getKey());
    expect(cust1x.getProperty("city")).toBeNull();
    cust0x.setProperty("companyName", "Foo");
    cust1x.setProperty("city", "Foo");
    cust0x.entityAspect.acceptChanges();
    cust1x.entityAspect.acceptChanges();
    em2.importEntities(exported);
    expect(cust0x.getProperty("companyName")).toBeNull();
    expect(cust1x.getProperty("city")).toBeNull();
  });

  test("export null vs. []", async function () {
    expect.hasAssertions();
    const queryOptions = new QueryOptions({
      mergeStrategy: MergeStrategy.OverwriteChanges,
      fetchStrategy: FetchStrategy.FromServer
    });
    const em = TestFns.newEntityManager()
    const pred = new breeze.Predicate("companyName", "!=", null).and("city", "!=", null);
    const q = EntityQuery.from("Customers").where(pred).take(2)
      .using(MergeStrategy.OverwriteChanges);
    const val = Date.now().toString();
    
    const qr1 = await em.executeQuery(q);
    // null case
    let exported = em.exportEntities(null, { includeMetadata: false });
    const em2 = TestFns.newEntityManager();
    em2.importEntities(exported);
    const all = new EntityQuery("Customers");
    let customers = em2.executeQueryLocally(all);
    expect(customers && customers.length === 2).toBe(true);
    // [] case
    exported = em.exportEntities([], { includeMetadata: false });
    const em3 = TestFns.newEntityManager();
    em3.importEntities(exported);
    customers = em3.executeQueryLocally(all);
    expect(customers && customers.length === 0).toBe(true);
    // [cust]
    const cust = qr1.results[0];
    exported = em.exportEntities([cust], { includeMetadata: false });
    const em4 = TestFns.newEntityManager();
    em4.importEntities(exported);
    customers = em4.executeQueryLocally(all);
    expect(customers && customers.length === 1).toBe(true);
  });

  test("relationship not resolved after import", async function () {
    expect.hasAssertions();
    const ds = new breeze.DataService({
      serviceName: "none",
      hasServerMetadata: false
    });

    const manager = new breeze.EntityManager({
      dataService: ds
    });

    manager.importEntities(exportImportSample1);

    const q2 = new breeze.EntityQuery("OrderHeaders")
        .using(breeze.FetchStrategy.FromLocalCache);

    
    const data2 = await manager.executeQuery(q2);
    const order = data2.results[0];
    //uncomment line below and the relationship is resolved
    //manager._linkRelatedEntities(order);
    const orderShipments = order.getProperty("orderShipments");
    expect(orderShipments.length).toBeGreaterThan(0);
  });

});
