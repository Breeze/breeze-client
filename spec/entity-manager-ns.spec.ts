import { EntityManager, EntityType, ComplexType, EntityState, EntityAction, EntityChangedEventArgs, breeze, MetadataStore, SaveOptions, QueryOptions, ValidationOptions, Entity, DataType, core, EntityKey, RelationArray } from 'breeze-client';
import { ModelLibraryBackingStoreAdapter } from 'breeze-client/adapter-model-library-backing-store';
import { TestFns } from './test-fns';
import { ObservableArrayChangedArgs } from 'src/observable-array';
import { PropertyChangedEventArgs } from 'src/entity-aspect';

ModelLibraryBackingStoreAdapter.register();

TestFns.initNonServerEnv();

describe("EntityManager - no server", () => {

  beforeEach(function() {
    TestFns.initSampleMetadataStore();
  });

  test("initialization", function () {
    const em = new EntityManager("foo");
    em.setProperties({
      queryOptions: new QueryOptions(),
      saveOptions: new SaveOptions(),
      validationOptions: new ValidationOptions()
    });
    expect(em).toBeTruthy();
  });

  test("should be able to create", () => {
    let em = new EntityManager('test');
    let r = em.getChanges();
    expect(r.length).toBe(0);
  });

  test("should load metadata", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let orderType = ms.getEntityType("Order") as EntityType;
    expect(orderType).toBeTruthy();

    expect(orderType.shortName).toEqual("Order");

    let custProp = orderType.getProperty("customer");
    expect(custProp.name).toEqual("customer");
    expect(custProp.isNavigationProperty).toBeTruthy();
  });  

  test("createEntity", () => {
    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let order = em.createEntity("Order", { shipName: "Barnum"});
    expect(order).toBeTruthy();

    let shipName = order.getProperty("shipName");
    expect(shipName).toEqual("Barnum");

    let orderID = order.getProperty("orderID");
    expect(orderID).toBeLessThanOrEqual(-1);
  });

  test("createEntity - 2", () => {
    const em = TestFns.newEntityManager();
    const emp1 = em.createEntity("Employee");
    expect(emp1.entityAspect.entityState).toBe(EntityState.Added);

    const emp2 = em.createEntity("Employee", { firstName: "John", lastName: "Smith" });
    expect(emp2.entityAspect.entityState).toBe(EntityState.Added);

    const emp3 = em.createEntity("Employee", { firstName: "John", lastName: "Smith" }, EntityState.Detached);
    expect(emp3.entityAspect.entityState).toBe(EntityState.Detached);
    expect(emp3.getProperty("lastName")).toBe("Smith");
  });

  test("createEntity and complex type", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let supplier = em.createEntity("Supplier", { companyName: "ACME"});
    expect(supplier).toBeTruthy();

    let locType = ms.getEntityType("Location") as ComplexType;
    expect(locType).toBeTruthy();
    let loc1 = locType.createInstance({ address: "111 Oak Street"});

    supplier.setProperty("location", loc1);
    let ok = supplier.entityAspect.validateEntity();
    expect(ok).toBeTruthy();

    let loc2 = supplier.getProperty("location");
    expect(loc2).toBeTruthy();
    expect(loc2.address).toEqual("111 Oak Street");
  });

  test("createEntity - duplicate entity keys", () => {
    const em = TestFns.newEntityManager();

    const cust1 = em.createEntity("Customer", null, EntityState.Detached);
    const cust2 = em.createEntity("Customer", null, EntityState.Detached);
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    em.attachEntity(cust1);
    try {
      const cust1Id = cust1.getProperty(customerKeyName);
      cust2.setProperty(customerKeyName, cust1Id);
      em.attachEntity(cust2);
      throw new Error('should not get here');
    } catch (e) {
      expect(e.message).toMatch(/key/);
    }
  });

  test("createEntity then detach and readd", () => {
    const em = TestFns.newEntityManager();
    const newOrder = em.createEntity("Order");

    em.detachEntity(newOrder);
    em.addEntity(newOrder); 
  });


  test("attachEntity then detach and reattach", () => {
    const em = TestFns.newEntityManager();
    const orderType = em.metadataStore.getAsEntityType("Order");
    const order = orderType.createEntity();
    em.attachEntity(order);

    em.detachEntity(order);
    em.attachEntity(order); 
  });

  test("attachEntity - store-managed int ID remains '0'", () => {
    const em = TestFns.newEntityManager();
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;
    const employeeType = em.metadataStore.getAsEntityType("Employee");
    const empIdProp = employeeType.getProperty(employeeKeyName);

    const defaultValue = 0;
    const emp = employeeType.createEntity();
    expect(emp.getProperty(employeeKeyName)).toBe(defaultValue);
    const agkType = employeeType.autoGeneratedKeyType;
    // manager should NOT replace '0' with generated temp id
    em.attachEntity(emp);
    const id = emp.getProperty(employeeKeyName);
    expect(id).toBe(defaultValue);
  });

  test("attachEntity - cannot attach an already attached entity created by a different metadataStore", () => {
    const em = TestFns.newEntityManager();
    const customerType = em.metadataStore.getAsEntityType("Customer");
    const customer = customerType.createEntity();
    
    const newMs = MetadataStore.importMetadata(em.metadataStore.exportMetadata());
    const em2 = TestFns.newEntityManager(newMs);

    expect( () => em2.attachEntity(customer)).toThrow(/MetadataStore/);
  });

  test("attachEntity - cannot attach across entityManagers", () => {
    const em1 = TestFns.newEntityManager();
    const custType = em1.metadataStore.getAsEntityType("Customer");
    const cust = custType.createEntity();

    const em2 = TestFns.newEntityManager();
    em1.attachEntity(cust);

    expect(() => em2.attachEntity(cust)).toThrow(/EntityManager/);
  });

  test("attachEntity - can attach a detached entity to a different manager via attach/detach",  () => {
      const em = TestFns.newEntityManager();
      const customerType = em.metadataStore.getAsEntityType("Customer");
      const customer = customerType.createEntity();
      const orderType = em.metadataStore.getAsEntityType("Order");
      const order = orderType.createEntity();
      em.attachEntity(customer);
      const orders = customer.getProperty("orders");
      expect(orders.length).toBe(0);
      orders.push(order);
      const em2 = TestFns.newEntityManager();
      em.detachEntity(customer);
      em2.attachEntity(customer);
      expect(customer.entityAspect.entityManager).toBe(em2);
    }
  );

  test("attachEntity - can attach a detached entity to a different manager via clear",   () => {
      const em1 = TestFns.newEntityManager();
      const cust = em1.metadataStore.getAsEntityType("Customer").createEntity() as Entity;
      cust.setProperty(TestFns.wellKnownData.keyNames.customer, core.getUuid());

      em1.attachEntity(cust);

      em1.clear(); // should detach cust
      expect(cust.entityAspect.entityState.isDetached()).toBe(true);

      // therefore this should be ok
      const em2 = TestFns.newEntityManager();
      em2.attachEntity(cust); // D#2206 throws exception
    }
  );

  test("addEntity followed by delete", () => {
    const em = TestFns.newEntityManager();
    const typeInfo = em.metadataStore.getAsEntityType("Order");

    const newEntity = em.createEntity(typeInfo);
    expect(newEntity.entityAspect.entityState.isAdded()).toBe(true);

    newEntity.entityAspect.setDeleted();
    expect(newEntity.entityAspect.entityState.isDetached()).toBe(true);

    // get the first (and only) entity in cache
    expect(em.getEntities().length).toBe(0);

  });

  test("addEntity followed by rejectChanges", () => {
    const em = TestFns.newEntityManager();
    const newEntity = em.createEntity("Order");

    let entityState = newEntity.entityAspect.entityState;
    expect(entityState.isAdded()).toBe(true);

    newEntity.entityAspect.rejectChanges();

    entityState = newEntity.entityAspect.entityState;
    expect(entityState.isDetached()).toBe(true);

    expect(em.hasChanges()).toBe(false);

    const inCache = em.getEntities(), count = inCache.length;
    expect(count).toBe(0);
  });

  test("addEntity - no key", function () {
    const em = TestFns.newEntityManager();
    const odType = em.metadataStore.getAsEntityType("OrderDetail");
    const od = odType.createEntity();
    expect(() => em.addEntity(od)).toThrow(/key/);
    expect(() => em.generateTempKeyValue(od)).toThrow(/multipart keys/);

    // only need to set part of the key
    od.setProperty("orderID", 999);
    em.addEntity(od);
    expect(true).toBe(true);
  });


  test("addEntity - no key 2", function () {
    const em = TestFns.newEntityManager();

    expect(() => em.createEntity("OrderDetail")).toThrow(/key/);

    const od = em.createEntity("OrderDetail", null, EntityState.Detached);
    expect(() => em.generateTempKeyValue(od)).toThrow(/multipart keys/);

    // only need to set part of the key
    od.setProperty("orderID", 999);
    em.addEntity(od);
    expect(true).toBe(true);
  });


  test("addEntity - child", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();

    em.addEntity(cust1);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Added);
    expect(cust1.entityAspect.hasTempKey).toBe(true);
    const orders = cust1.getProperty("orders") as RelationArray;

    let changeArgs: ObservableArrayChangedArgs = null;
    orders.arrayChanged.subscribe((args) => {
      changeArgs = args;
    });
    orders.push(order1);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Added);
    expect(order1.entityAspect.entityState).toBe(EntityState.Added);
    expect(orders.parentEntity).toBe(cust1);
    const navProperty = cust1.entityType.getProperty("orders");
    expect(orders.navigationProperty).toBe(navProperty);
    expect(changeArgs.added).toBeTruthy();
    expect(changeArgs.added[0]).toBe(order1);
    const sameCust = order1.getProperty("customer");
    expect(sameCust).toBe(cust1);

  });

  test("addEntity - detach child", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();
    const order2 = orderType.createEntity() as Entity;

    em.addEntity(cust1);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Added);
    const orders = cust1.getProperty("orders") as RelationArray;
    orders.push(order1);
    orders.push(order2);
    let arrayChangeCount = 0;
    orders.arrayChanged.subscribe(function (args) {
      arrayChangeCount += 1;
      expect(args.removed[0]).toBe(order2);
    });
    let order2ChangeCount = 0;
    order2.entityAspect.propertyChanged.subscribe(function (args2) {
      expect(args2.entity).toBe(order2);
      if (args2.propertyName === "customer") {
        order2ChangeCount += 1;
      } else if (args2.propertyName === "customerID") {
        order2ChangeCount += 1;
      } else {
        throw new Error("should not have gotten here");
      }
    });
    const orders2 = cust1.getProperty("orders");
    expect(orders).toBe(orders2);
    const ix = (orders as any).indexOf(order2);
    orders.splice(ix, 1);
    expect(orders.length).toBe(1);
    expect(arrayChangeCount).toBe(1);
    expect(order2ChangeCount).toBe(2);

    const sameCust = order2.getProperty("customer");
    expect(sameCust).toBeNull;
  });

  test("addEntity - add parent", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity() as Entity;


    em.addEntity(order1);
    expect(order1.entityAspect.entityState.isAdded()).toBe(true);
    const emptyCust = order1.getProperty("customer");
    expect(!emptyCust);
    let changeArgs: PropertyChangedEventArgs = null;
    order1.entityAspect.propertyChanged.subscribe((args) => {
      changeArgs = args;
    });
    order1.setProperty("customer", cust1);
    expect(order1.entityAspect.entityState.isAdded()).toBe(true);
    expect(cust1.entityAspect.entityState.isAdded()).toBe(true);
    expect(changeArgs).toBeTruthy();
    expect(changeArgs.propertyName).toBe("customer");
    expect(changeArgs.newValue).toBe(cust1);
    expect(changeArgs.oldValue).toBeNull;
    const orders = cust1.getProperty("orders");
    expect(orders[0]).toBe(order1);
  });


  test("connect entities using foreign key", () => {
    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let order = em.createEntity("Order", { orderID: ordID, shipName: "Barnum"});
    expect(order).toBeTruthy();   
    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    expect(cust).toBeTruthy();

    let orderCust = order.getProperty("customer");
    expect(orderCust).toBeNull();

    order.setProperty("customerID", custID);

    orderCust = order.getProperty("customer");
    expect(orderCust).toEqual(cust);

    let custOrders = cust.getProperty("orders");
    expect(custOrders).toBeTruthy();
    expect(custOrders.length).toEqual(1);
    expect(custOrders[0]).toEqual(order);

  });

  test("connect entities when added to navigation collection array", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let order = em.createEntity("Order", { orderID: ordID, shipName: "Barnum"});
    expect(order).toBeTruthy();   
    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    expect(cust).toBeTruthy();

    let custOrders = cust.getProperty("orders");
    expect(custOrders).toBeTruthy();
    expect(custOrders.length).toEqual(0);

    custOrders.push(order);

    let orderCust = order.getProperty("customer");
    expect(orderCust).toEqual(cust);

    expect(custOrders.length).toEqual(1);
    expect(custOrders[0]).toEqual(order);
  });

  test("connect entities disallowed when setting collection navigation properties", () => {

    const em = TestFns.newEntityManager();
    const customerType = em.metadataStore.getAsEntityType("Customer");
    const customer = customerType.createEntity();
    const orderType = em.metadataStore.getAsEntityType("Order");
    const order = orderType.createEntity();
    em.attachEntity(customer);
    const origOrders = customer.getProperty("orders");
    expect(origOrders.length).toBe(0);
    origOrders.push(order);
    expect(origOrders.length).toBe(1);
    try {
      customer.setProperty("orders", ["foo", "bar"]);
      throw new Error("should not get here");
    } catch (e) {
      expect(e.message).toMatch(/navigation/);
      expect(customer.getProperty("orders")).toBe(origOrders);
    }
  });

  test("connect entities when fk set in constructor", () => {
    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    let order = em.createEntity("Order", { orderID: ordID, customerID: custID, shipName: "Barnum"});

    let custOrders = cust.getProperty("orders");
    let orderCust = order.getProperty("customer");
    expect(orderCust).toEqual(cust);

    expect(custOrders.length).toEqual(1);
    expect(custOrders[0]).toEqual(order);
  });

  test("connect entities - changing a child FK to ID of entity-not-in cache clears the navigation", function() {
    const em = TestFns.newEntityManager();
    const dummyCustID = breeze.core.getUuid();

    // create a parent Customer and its child order
    const parentCustomer = em.createEntity("Customer", {
      customerID: dummyCustID,
      companyName: 'TestCo'
    }, EntityState.Unchanged);

    const order = em.createEntity("Order", {
      customerID: parentCustomer.getProperty("customerID")
    }, EntityState.Unchanged);


    let orderCustomer = order.getProperty("customer");
    expect(orderCustomer).toBeTruthy();

    // change FK to ID of an entity not-in-cache
    order.setProperty("customerID", TestFns.wellKnownData.alfredsID);

    orderCustomer = order.getProperty("customer");
    expect(orderCustomer).toBeNull();
  });

  test("connect entities - unidirectional n-> 1", () => {
    const em = TestFns.newEntityManager();
    const orderDetailType = em.metadataStore.getAsEntityType("OrderDetail");
    const orderDetail = orderDetailType.createEntity();
    const productType = em.metadataStore.getAsEntityType("Product");
    const product = productType.createEntity();
    orderDetail.setProperty("productID", -99);
    em.attachEntity(orderDetail);
    em.attachEntity(product);
    const nullProduct = orderDetail.getProperty("product");
    expect(nullProduct).toBeNull();
    product.setProperty("productID", 7);
    orderDetail.setProperty("productID", 7);
    const sameProduct = orderDetail.getProperty("product");
    expect(product).toBe(sameProduct);

  });

  // testFns.skipIf("odata,hibernate", "does not have TimeList and Timegroup tables").
  test("connect entities - unidirectional 1-> n", () => {
    const em = TestFns.newEntityManager();

    const tl1 = em.createEntity("TimeLimit");
    const tl2 = em.createEntity("TimeLimit");
    const tg1 = em.createEntity("TimeGroup");
    const id = tg1.getProperty("id");
    tl1.setProperty("timeGroupId", id);
    const timeLimits = tg1.getProperty("timeLimits");
    expect(timeLimits.length).toBe(1);
    tl2.setProperty("timeGroupId", id);
    expect(timeLimits.length).toBe(2);
  });

  // testFns.skipIf("odata,hibernate", "does not have TimeList and Timegroup tables").
  test("connect entities - unidirectional 1-> n - part 2", () => {
    const em = TestFns.newEntityManager();

    const tl1 = em.createEntity("TimeLimit");
    const tl2 = em.createEntity("TimeLimit");
    const tg1 = em.createEntity("TimeGroup");
    const timeLimits = tg1.getProperty("timeLimits");
    expect(timeLimits.length).toBe(0);
    timeLimits.push(tl1);
    expect(timeLimits.length).toBe(1);
    timeLimits.push(tl2);
    expect(timeLimits.length).toBe(2);
    const timeLimits2 = tg1.getProperty("timeLimits");
    expect(timeLimits).toBe(timeLimits2);
    // add one that is already there
    timeLimits.push(tl1);
    expect(timeLimits.length).toBe(2);
  });

  test("connect entities via primary key", () => {
    const em = TestFns.newEntityManager();
    const productType = em.metadataStore.getAsEntityType("Product");
    const product = productType.createEntity();
    const productKeyName = TestFns.wellKnownData.keyNames.product;
    em.attachEntity(product);
    const origProductId = product.getProperty(productKeyName);
    let entityKey = new EntityKey(productType, [origProductId]);
    let sameProduct = em.findEntityByKey(entityKey);
    const sameProduct2 = em.getEntityByKey("Product", origProductId);
    expect(product).toBe(sameProduct);
    expect(product).toBe(sameProduct2);
    product.setProperty(productKeyName, 7);
    sameProduct = em.getEntityByKey(entityKey);
    expect(sameProduct).toBe(null);
    entityKey = new EntityKey(productType, [7]);
    sameProduct = em.findEntityByKey(entityKey);
    expect(product).toBe(sameProduct);
  });

  test("connect entities - changing FK to null removes it from old parent", () => {
    const em = TestFns.newEntityManager();
    const customerType = em.metadataStore.getAsEntityType("Customer");
    const customer = customerType.createEntity();
    em.attachEntity(customer);
    const newOrder = em.createEntity("Order", { customer: customer });
    expect(customer.getProperty("orders").indexOf(newOrder) >= 0).toBe(true);
    newOrder.setProperty("customerID", null);
    expect(customer.getProperty("orders").indexOf(newOrder)).toBe(-1);
  });

  test("connect entities - setting child's parent entity null removes it from old parent", () => {
    const em = TestFns.newEntityManager();
    const customerType = em.metadataStore.getAsEntityType("Customer");
    const customer = customerType.createEntity();
    em.attachEntity(customer);

    const newOrder = em.createEntity("Order", { customer: customer });
    let orders = customer.getProperty("orders");
    expect(orders.indexOf(newOrder) >= 0).toBe(true);

    newOrder.setProperty("customer", null); // set null to decouple the order from a customer
    orders = customer.getProperty("orders");
    expect(orders).not.toContain(newOrder);
  });

  test("connect entities - fk to nav - attached", () => {
    const em = TestFns.newEntityManager();
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const cust1 = em.createEntity("Customer", null, EntityState.Detached);
    const order1 = em.createEntity("Order", null, EntityState.Detached);

    em.attachEntity(order1);
    em.attachEntity(cust1);

    const custIdValue = cust1.getProperty(customerKeyName);
    order1.setProperty("customerID", custIdValue);
    const orderCustomer = order1.getProperty("customer");
    expect(orderCustomer).toBe(cust1);

  });

  test("connect entities - nav to fk - attached", () => {
    const em = TestFns.newEntityManager();
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const cust1 = em.createEntity("Customer", null, EntityState.Detached);
    const orderType = em.metadataStore.getAsEntityType("Order");
    const order1 = em.createEntity(orderType, null, EntityState.Detached);

    em.attachEntity(order1);
    em.attachEntity(cust1);

    order1.setProperty("customer", cust1);
    const orderCustId = order1.getProperty("customerID");
    const custId = cust1.getProperty(customerKeyName);
    expect(orderCustId).toBe(custId);

  });

  test("connect entities - unattached children", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const c1Id = em.generateTempKeyValue(cust1);
    const cust2 = custType.createEntity();
    const order1 = orderType.createEntity();
    em.attachEntity(order1);
    expect(order1.entityAspect.entityState.isUnchanged()).toBe(true);
    // assign an fk where the parent doesn't yet exist on  this em.
    order1.setProperty("customerID", c1Id);
    expect(order1.entityAspect.entityState.isModified()).toBe(true);
    order1.entityAspect.acceptChanges();
    expect(order1.entityAspect.entityState.isUnchanged()).toBe(true);
    let order1Cust = order1.getProperty("customer");
    expect(order1Cust == null).toBe(true);
    em.attachEntity(cust1);
    order1Cust = order1.getProperty("customer");
    expect(order1Cust !== null).toBe(true);
    expect(order1.entityAspect.entityState.isUnchanged()).toBe(true);
  });

  test("connect entities - unattached parent pushes attached child", () => {
    const em = TestFns.newEntityManager();
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const c1Id = em.generateTempKeyValue(cust1);
    const cust2 = custType.createEntity();
    const order1 = orderType.createEntity();
    em.attachEntity(order1);
    expect(order1.entityAspect.entityState.isUnchanged()).toBe(true);
    expect(cust1.entityAspect.entityState.isDetached()).toBe(true);
    let order1Cust = order1.getProperty("customer");
    expect(order1Cust == null).toBe(true);
    const cust1Orders = cust1.getProperty("orders");
    cust1Orders.push(order1);
    expect(order1.entityAspect.entityState.isModified()).toBe(true);
    expect(cust1.entityAspect.entityState.isAdded()).toBe(true);
    order1Cust = order1.getProperty("customer");
    expect(order1Cust !== null).toBe(true);
    const order1CustId = order1.getProperty("customerID");
    const custId = cust1.getProperty(customerKeyName);
    expect(order1CustId).toBe(custId);

  });

  test("connect entities - recursive navigation fixup", () => {
    const em = TestFns.newEntityManager();
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;
    const emp1 = em.createEntity("Employee", null, EntityState.Detached);
    const emp2 = em.createEntity("Employee", null, EntityState.Detached);
    const emp3 = em.createEntity("Employee", null, EntityState.Detached);

    expect(emp1.entityAspect.entityState.isDetached()).toBe(true);
    expect(emp2.entityAspect.entityState.isDetached()).toBe(true);
    expect(emp3.entityAspect.entityState.isDetached()).toBe(true);
    emp2.setProperty("manager", emp1);
    emp2.getProperty("directReports").push(emp3);
    em.addEntity(emp3);
    expect(emp1.entityAspect.entityState.isAdded()).toBe(true);
    expect(emp2.entityAspect.entityState.isAdded()).toBe(true);
    expect(emp3.entityAspect.entityState.isAdded()).toBe(true);
    const emp1Id = emp1.getProperty(employeeKeyName);
    const emp2Id = emp2.getProperty(employeeKeyName);
    const emp3Id = emp3.getProperty(employeeKeyName);
    expect(emp2.getProperty("reportsToEmployeeID")).toBe(emp1Id);
    expect(emp3.getProperty("reportsToEmployeeID")).toBe(emp2Id);
    expect(emp2.getProperty("directReports")[0]).toBe(emp3);
    expect(emp1.getProperty("directReports")[0]).toBe(emp2);
  });

  test("connect entities - exception if set nav to entity with different manager", () => {
    const em1 = TestFns.newEntityManager();
    const orderType = em1.metadataStore.getAsEntityType("Order");
    const o1 = orderType.createEntity();
    em1.attachEntity(o1);

    const em2 = TestFns.newEntityManager();
    const customerType = em2.metadataStore.getAsEntityType("Customer");
    const c1 = customerType.createEntity();
    em2.attachEntity(c1);

    expect(c1.entityAspect.entityManager).not.toBe(o1.entityAspect.entityManager);
    expect(() => o1.setProperty("customer", c1)).toThrow(/EntityManager/);

  });

  test("connect entities - change parent (1-n)", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const cust2 = custType.createEntity();
    const order1 = orderType.createEntity();

    em.attachEntity(order1);
    expect(order1.entityAspect.entityState.isUnchanged()).toBe(true);
    order1.setProperty("customer", cust1);
    expect(cust1.entityAspect.entityState.isAdded()).toBe(true);
    const cust1Orders = cust1.getProperty("orders");
    expect(cust1Orders.length).toBe(1);
    expect(cust1Orders).toContain(order1);

    // now change
    order1.setProperty("customer", cust2);
    expect(cust2.entityAspect.entityState.isAdded()).toBe(true);
    const cust2Orders = cust2.getProperty("orders");
    expect(cust2Orders.length).toBe(1);
    expect(cust2Orders).toContain(order1);
    expect(cust1Orders).toBe(cust1.getProperty("orders"));
    expect(cust1Orders).not.toContain(order1);
    expect(order1.getProperty("customer")).toBe(cust2);

  });

  test("connect entities - change child (1-n)", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const cid1 = em.generateTempKeyValue(cust1);
    const cust2 = custType.createEntity();
    const cid2 = em.generateTempKeyValue(cust2);
    const order1 = orderType.createEntity();

    em.attachEntity(cust1);

    expect(cust1.entityAspect.entityState.isUnchanged()).toBe(true);
    const cust1Orders = cust1.getProperty("orders");
    cust1Orders.push(order1);
    expect(cust1Orders.length).toBe(1);

    expect(order1.entityAspect.entityState.isAdded()).toBe(true);
    expect(cust1Orders).toContain(order1);
    // now change
    const cust2Orders = cust2.getProperty("orders");
    cust2Orders.push(order1);
    expect(cust2Orders.length).toBe(1);
    expect(cust1Orders.length).toBe(0);
    expect(cust2.entityAspect.entityState.isAdded()).toBe(true);
    expect(cust2Orders).toContain(order1);
    expect(cust1Orders).toBe(cust1.getProperty("orders"));
    expect(cust1Orders).not.toContain(order1);
    expect(order1.getProperty("customer")).toBe(cust2);
  });


  test("disconnect entities - FK to null when nav property set to null", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    let order = em.createEntity("Order", { orderID: ordID, customerID: custID, shipName: "Barnum"});
    let orderCustId = order.getProperty("customerID");
    expect(orderCustId).toEqual(custID);

    order.setProperty("customer", null);

    let custOrders = cust.getProperty("orders");
    let orderCust = order.getProperty("customer");
    expect(orderCust).toBeNull();
    expect(custOrders.length).toEqual(0);
    orderCustId = order.getProperty("customerID");
    expect(orderCustId).toBeNull();
  });

  test("disconnect entities - FK to null when nav property set to undefined", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    let order = em.createEntity("Order", { orderID: ordID, customerID: custID, shipName: "Barnum"});
    let orderCust = order.getProperty("customer");
    expect(orderCust).toEqual(cust);
    // order.setProperty("customer", undefined);
    (order as any).customer = undefined;

    let custOrders = cust.getProperty("orders");
    // orderCust = order.getProperty("customer");
    orderCust = (order as any).customer;
    expect(orderCust).toBeNull();
    expect(custOrders.length).toEqual(0);
    let orderCustId = order.getProperty("customerID");
    expect(orderCustId).toBeNull();
  });

  test("disconnect entities - FK to null when nav property is initially undefined", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    let order = em.createEntity("Order", { orderID: ordID, shipName: "Barnum"});
    
    order.setProperty("customer", undefined);

    let custOrders = cust.getProperty("orders");
    // orderCust = order.getProperty("customer");
    let orderCust = (order as any).customer;
    expect(orderCust).toBeNull();
    expect(custOrders.length).toEqual(0);
    let orderCustId = order.getProperty("customerID");
    expect(orderCustId).toBeNull();
  });


  test("disconnect entities when fk set to null", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    let order = em.createEntity("Order", { orderID: ordID, customerID: custID, shipName: "Barnum"});

    order.setProperty("customerID", null);

    let custOrders = cust.getProperty("orders");
    let orderCust = order.getProperty("customer");
    expect(orderCust).toBeNull();
    expect(custOrders.length).toEqual(0);   
  });

  test("disconnect entities when fk set to undefined", () => {

    let em = new EntityManager('test');
    let ms = em.metadataStore;
    ms.importMetadata(TestFns.sampleMetadata);

    let custID = "88888888-4444-4444-4444-121212121212";
    let ordID = 22;

    let cust = em.createEntity("Customer", { customerID: custID, companyName: "Wishbone"});
    let order = em.createEntity("Order", { orderID: ordID, customerID: custID, shipName: "Barnum"});

    order.setProperty("customerID", undefined);

    let custOrders = cust.getProperty("orders");
    let orderCust = order.getProperty("customer");
    expect(orderCust).toBeNull();
    expect(custOrders.length).toEqual(0);   
  });

  
  test("getChanges", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");
    const empType = em.metadataStore.getAsEntityType("Employee");
    const custType = em.metadataStore.getAsEntityType("Customer");
    for (let i = 0; i < 5; i++) {
      em.addEntity(orderType.createEntity()).entityAspect.setUnchanged();
      em.addEntity(empType.createEntity()).entityAspect.setUnchanged();
    }
    for (let i = 0; i < 5; i++) {
      em.addEntity(orderType.createEntity()).entityAspect.setModified();
      em.addEntity(empType.createEntity());
    }
    const c1 = em.getChanges();
    expect(c1.length).toBe(10);
    const c2 = em.getChanges("Order");
    expect(c2.length).toBe(5);
    const c3 = em.getChanges([orderType, custType]);
    expect(c3.length).toBe(5);
    const c4 = em.getChanges([orderType, empType]);
    expect(c4.length).toBe(10);
    const c5 = em.getEntities(["Order"], EntityState.Modified);
    expect(c5.length).toBe(5);
    const c6 = em.getEntities([orderType], EntityState.Added);
    expect(c6.length).toBe(0);
    const c7 = em.getEntities(null, EntityState.Added);
    expect(c7.length).toBe(5);
    const c8 = em.getEntities(null, [EntityState.Added, EntityState.Modified]);
    expect(c8.length).toBe(10);
  });

  test("hasChanges basic", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");

    let  count = 0;
    em.hasChangesChanged.subscribe( args => {
      count = count + 1;
    });
    expect(count).toBe(0);
    expect(em.hasChanges()).toBe(false);
    const order1 = orderType.createEntity();
    // attach - no event
    em.attachEntity(order1);
    expect(count).toBe(0);
    expect(em.hasChanges()).toBe(false);
    const order2 = orderType.createEntity();
    // add - event 
    em.addEntity(order2);
    expect(count).toBe(1);
    expect(em.hasChanges()).toBe(true);

    em.rejectChanges();
    expect(em.hasChanges()).toBe(false);
  });


  test("hasChanges filtering by type", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    em.createEntity('Order');
    em.createEntity('Product', null, breeze.EntityState.Unchanged);
    // There are Order changes but there are no Product changes
    expect(em.hasChanges()).toBe(true);
    expect(em.hasChanges(['Order'])).toBe(true);
    expect(em.hasChanges(['Product'])).toBe(false);
  });

  // D#2663
  test("hasChanges is false when filter for a type that is not in cache", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    em.createEntity('Order');
    // While 'Product' is a defined type, there are no Products in cache this time.
    // There are changes but there are no Product changes
    const hasChanges = em.hasChanges();
    expect(em.hasChanges()).toBe(true);
    expect(em.hasChanges(['Product'])).toBe(false);
  });

  test("hasChanges throws error when filter for a type that doesn't exist", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    em.createEntity('Order');
    
    expect(em.hasChanges()).toBe(true);
    // There are changes but there is no 'Foo' type
    expect(function() {
      em.hasChanges(['Foo']);
    }).toThrow(/unable to locate a 'Type'/i);
  });

  test("hasChanges with em.acceptChanges", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");
    expect(em.hasChanges()).toBe(false);
    const order1 = orderType.createEntity();
    em.attachEntity(order1);
    // attach causes no changes
    expect(em.hasChanges()).toBe(false);
    const order2 = orderType.createEntity();
    em.addEntity(order2);
    // but add does
    expect(em.hasChanges()).toBe(true);
    em.acceptChanges();
    expect(em.hasChanges()).toBe(false);
  });

  test("hasChanges with rejectChanges", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");
    let count = 0;
    em.hasChangesChanged.subscribe(args => {
      count = count + 1;
     });
    expect(count).toBe(0);
    expect(em.hasChanges()).toBe(false);
    const order1 = orderType.createEntity();
    em.attachEntity(order1);
    order1.entityAspect.setModified();
    expect(count).toBe(1);
    expect(em.hasChanges()).toBe(true);
    const order2 = orderType.createEntity();
    em.addEntity(order2);
    expect(count).toBe(1);
    expect(em.hasChanges()).toBe(true);
    order1.entityAspect.rejectChanges();
    expect(count).toBe(1);
    expect(em.hasChanges()).toBe(true);
    order2.entityAspect.rejectChanges();
    expect(count).toBe(2);
    expect(em.hasChanges()).toBe(false);
  });


  test("entityChanged event", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");
    const empType = em.metadataStore.getAsEntityType("Employee");
    const custType = em.metadataStore.getAsEntityType("Customer");

    let changedArgs: any[] = [];
    let lastArgs: EntityChangedEventArgs, lastAction, lastEntity;
    em.entityChanged.subscribe( args => {
      changedArgs.push(args);
      lastArgs = args;
      lastAction = args.entityAction;
      lastEntity = args.entity;
    });
    const order = orderType.createEntity();
    
    em.addEntity(order);
    expect(lastAction).toBe(EntityAction.Attach);
    expect(lastEntity).toBe(order);

    const emp = empType.createEntity();
    changedArgs = [];
    em.attachEntity(emp);
    expect(lastAction).toBe(EntityAction.Attach);
    expect(lastEntity).toBe(emp);

    emp.setProperty("lastName", "Smith");
    expect(lastAction).toBe(EntityAction.PropertyChange);
    expect(lastEntity).toBe(emp);
    expect(lastArgs.args.propertyName).toBe("lastName");

    changedArgs = [];
    emp.entityAspect.rejectChanges();
    expect(changedArgs[0].entityAction).toBe(EntityAction.EntityStateChange);
    expect(changedArgs[1].entityAction).toBe(EntityAction.RejectChanges);
    expect(lastEntity).toBe(emp);

    emp.setProperty("lastName", "Jones");
    changedArgs = [];
    emp.entityAspect.acceptChanges();
    expect(changedArgs[0].entityAction).toBe(EntityAction.EntityStateChange);
    expect(changedArgs[1].entityAction).toBe(EntityAction.AcceptChanges);
    expect(lastEntity).toBe(emp);

    em.clear();
    expect(lastAction).toBe(EntityAction.Clear);
    expect(lastEntity).toBeUndefined();
  });

  test("entityChanged event on multiple setDeleted calls", function () {
    const em = TestFns.newEntityManager();
    const entity1 = em.createEntity("Customer");
    const entity2 = em.createEntity("Customer");
    const entity3 = em.createEntity("Customer");
    const entity4 = em.createEntity("Customer");
    entity1.entityAspect.acceptChanges();
    entity2.entityAspect.acceptChanges();
    entity3.entityAspect.acceptChanges();
    entity4.entityAspect.acceptChanges();
    let changedCount = 0;
    em.entityChanged.subscribe(function (changeArgs) {
      changedCount++;
    });
    entity1.entityAspect.setDeleted();
    // entityChanged is called on the manager, where entityAction === EntityStateChange - all good.
    expect(changedCount).toBe(1);
    entity2.entityAspect.setDeleted();
    expect(changedCount).toBe(2);
    // entityChanged event no longer fired on the manager.
    entity3.entityAspect.setDeleted();
    expect(changedCount).toBe(3);
    // same problem
    entity4.entityAspect.setDeleted();
    expect(changedCount).toBe(4);
  });

  test("entityChanged event and hasChanges interop", function () {
    const em = TestFns.newEntityManager();

    const emp = em.createEntity("Employee", { firstName: "Joe", lastName: "Smith", birthDate: new Date(2000, 1, 1) });
    emp.entityAspect.acceptChanges();
    em.entityChanged.subscribe(function (args) {
      const hasChanges = em.hasChanges();
      expect(hasChanges).toBe(true);
    });
    emp.setProperty("firstName", "test");
    expect(em.hasChanges());
  });


  test("entityChanged event 'isEnabled'", () => {
      // D#2652
      // see http://www.breezejs.com/sites/all/apidocs/classes/Event.html#method_isEnabled
      // which also describes EntityManager having propertyChanged event which it doesn't
      const em = TestFns.newEntityManager();
      const eventEnabled = breeze.Event.isEnabled("entityChanged", em);
      expect(eventEnabled).not.toBeUndefined();
  });

  test("entityChanged event suppressed", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");
    const empType = em.metadataStore.getAsEntityType("Employee");
    const custType = em.metadataStore.getAsEntityType("Customer");

    const changedArgs: EntityChangedEventArgs[] = [];
    breeze.Event.enable("entityChanged", em, false);
    em.entityChanged.subscribe(function (args) {
      changedArgs.push(args);
    });
    const order = orderType.createEntity();
    em.addEntity(order);
    const emp = empType.createEntity();
    em.attachEntity(emp);
    emp.setProperty("lastName", "Smith");
    emp.entityAspect.rejectChanges();
    emp.setProperty("lastName", "Jones");
    emp.entityAspect.acceptChanges();
    em.clear();
    expect(changedArgs.length).toBe(0);
  });

  test("entityChanged event suppressed by function", function () {
    const em = TestFns.newEntityManager(TestFns.sampleMetadataStore);
    const orderType = em.metadataStore.getAsEntityType("Order");
    const empType = em.metadataStore.getAsEntityType("Employee");
    em['tag'] = "foo";
    const changedArgs = [];
    breeze.Event.enable("entityChanged", em, em => em.tag === "enabled");
    em.entityChanged.subscribe(function (args) {
      changedArgs.push(args);
    });
    const order = orderType.createEntity();
    em.addEntity(order);
    const emp = empType.createEntity();
    em.attachEntity(emp);
    emp.setProperty("lastName", "Smith");
    emp.entityAspect.rejectChanges();
    emp.setProperty("lastName", "Jones");
    emp.entityAspect.acceptChanges();
    em.clear();
    expect(changedArgs.length).toBe(0);
  });

  test("detached entity - setting another EntityState on a detached entity throws exception",
    () => {
      const em = TestFns.newEntityManager(); // new empty EntityManager
      const order = em.createEntity('Order', { OrderID: 1 });

      const aspect = order.entityAspect;

      aspect.setDetached();
      expect(aspect.entityState.isDetached()).toBeTruthy();

      expect(() => aspect.setDeleted()).toThrow(/detached/);
      expect(() => aspect.setModified()).toThrow(/detached/);
      expect(() => aspect.setUnchanged()).toThrow(/detached/);

    }
  );

  test("detached entity retains its foreign keys", () => {
    const em = TestFns.newEntityManager();
    const cust = em.createEntity("Customer", { companyName: "TestXXX" });
    const emp = em.createEntity("Employee", { firstName: "John", lastName: "Smith" });
    const order = em.createEntity('Order', {
      orderID: 1,
      customer: cust,
      employee: emp
    });

    // Pre-detach asserts
    expect(order.getProperty('customerID')).toBe(cust.getProperty('customerID'));
    expect(order.getProperty('employeeID')).toBe(emp.getProperty('employeeID'));
    expect(order.getProperty('customer')).toBe(cust);
    expect(order.getProperty('employee')).toBe(emp);

    order.entityAspect.setDetached();

    // Post-detach asserts
    expect(order.getProperty('customerID')).toBe(cust.getProperty('customerID'));
    expect(order.getProperty('employeeID')).toBe(emp.getProperty('employeeID'));
    expect(order.getProperty('customer')).toBe(null);
    expect(order.getProperty('employee')).toBe(null);
    expect(order.entityAspect.originalValues).toEqual({});
  });

  test("acceptChanges - detach deleted", function () {
    const em = TestFns.newEntityManager(); // new empty EntityManager
    const empType = em.metadataStore.getAsEntityType("Employee");
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;

    const employee = empType.createEntity(); // created but not attached
    employee.setProperty(employeeKeyName, 42);
    em.attachEntity(employee); // simulate existing employee

    employee.entityAspect.setDeleted();
    employee.entityAspect.acceptChanges(); // simulate post-save state
    //em.acceptChanges(); // this works too ... for all changed entities in cache

    expect(employee.entityAspect.entityState.isDetached()).toBe(true);
  });

  test("rejectChanges notification", function () {
    //1) attach propertyChangedHandler to an existing entity
    //2) modify entity (handler hears it, and reports that the entity is "Modified")
    //3) entity.entityAspect.rejectChanges()
    //4) handler hears it ... but reports "Modified" rather than "Unchanged"
    const em = TestFns.newEntityManager();

    const orderType = em.metadataStore.getAsEntityType("Order");
    const orderKeyName = TestFns.wellKnownData.keyNames.order;
    const order = orderType.createEntity() as Entity;
    order.setProperty(orderKeyName, 1);
    em.attachEntity(order);
    let count = 0;
    let lastArgs: PropertyChangedEventArgs;

    order.entityAspect.propertyChanged.subscribe(function (args) {
      count++;
      lastArgs = args;
    });
    order.setProperty("freight", 55.55);
    expect(count).toBe(1);
    expect(lastArgs.entity).toBe(order);
    expect(lastArgs.propertyName).toBe("freight");
    expect(lastArgs.entity.entityAspect.entityState.isModified()).toBe(true);
    order.entityAspect.rejectChanges();
    expect(count).toBe(2);
    expect(lastArgs.entity).toBe(order);
    expect(lastArgs.propertyName).toBeNull();
    expect(lastArgs.entity.entityAspect.entityState.isUnchanged()).toBe(true);
  });

  test("rejectChanges on unmapped property", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.sampleMetadata));
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    await em1.fetchMetadata();
    const custType = em1.metadataStore.getAsEntityType("Customer");
    const cust = custType.createEntity();
    em1.addEntity(cust);
    cust.setProperty("companyName", "foo2");
    cust.setProperty("miscData", "zzz");
    cust.entityAspect.acceptChanges();
    cust.setProperty("miscData", "xxx");
    cust.entityAspect.rejectChanges();
    const miscData = cust.getProperty("miscData");
    expect(miscData).toBe('zzz');
  });

  test("rejectChanges with ES5 props", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.sampleMetadata));
    const Customer = TestFns.CustomerWithES5Props();
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    await em1.fetchMetadata();
    const custType = em1.metadataStore.getAsEntityType("Customer");
    const cust = custType.createEntity();
    em1.addEntity(cust);
    cust.setProperty("companyName", "foo2");
    const companyName = cust.getProperty("companyName");
    expect(companyName).toBe("FOO2");
    cust.entityAspect.acceptChanges();
    cust.setProperty("companyName", "foo3");
    const companyName_1 = cust.getProperty("companyName");
    expect(companyName).toBe("FOO3");
    cust.entityAspect.rejectChanges();
    const companyName_2 = cust.getProperty("companyName");
    expect(companyName).toBe('FOO2');
  });


  test("rejectChanges of a child entity restores it to its parent", function () {
    const em = TestFns.newEntityManager();

    const orderType = em.metadataStore.getAsEntityType("Order");
    const parent = orderType.createEntity();
    parent.setProperty("orderID", 1);
    em.attachEntity(parent);

    const orderDetailType = em.metadataStore.getAsEntityType("OrderDetail");
    const child = orderDetailType.createEntity();
    child.setProperty("orderID", 42);
    child.setProperty("order", parent); // adds child to parent's manager
    child.entityAspect.setUnchanged();

    // parent and child are now unchanged ... as if freshly queried
    expect(em.hasChanges()).toBe(false);
    child.entityAspect.setDeleted();

    // child should still have the parent's FK Id after delete
    expect(parent.getProperty("orderID")).toBe(child.getProperty("orderID"));
    expect(child.getProperty("order")).toBeNull();
    // parent should no longer have the child after child delete
    expect(parent.getProperty("orderDetails").length).toBe(0);
    em.rejectChanges();

    expect(em.hasChanges()).toBe(false);
    expect(parent.getProperty("orderID")).toBe(child.getProperty("orderID"));
    expect(parent).toBe(child.getProperty("order"));
    expect(parent.getProperty("orderDetails")[0]).toBe(child);
  });

  test("rejectChanges of a child entity restores it to its parent - v2", function () {
    const em = TestFns.newEntityManager();

    const parent = em.createEntity("Customer", { customerID: breeze.core.getUuid(), companyName: "Test 111" });
    parent.entityAspect.acceptChanges();

    const child = em.createEntity("Order", { orderID: 1 });
    child.setProperty("customerID", parent.getProperty("customerID"));
    child.entityAspect.acceptChanges();
    // parent and child are now unchanged ... as if freshly queried

    expect(child.getProperty("customer")).toBe(parent);
    expect(em.hasChanges()).toBe(false);

    child.entityAspect.setDeleted();

    expect(parent.getProperty("customerID")).toBe(child.getProperty("customerID"));
    expect(child.getProperty("customer")).toBeNull();
    expect(parent.getProperty("orders").length).toBe(0);

    em.rejectChanges();

    expect(em.hasChanges()).toBe(false);
    expect(parent.getProperty("customerID")).toBe(child.getProperty("customerID"));
    expect(parent).toBe(child.getProperty("customer"));
    expect(parent.getProperty("orders")[0]).toBe(child);
  });


  test("rejectChanges with boolean values", () => {
    const em = TestFns.newEntityManager();
    const propName = "isDiscontinued"; // 'discontinued'
    const emp1 = em.createEntity("Product", null, EntityState.Detached);
    emp1.setProperty(propName, false);
    em.attachEntity(emp1);
    emp1.setProperty(propName, true);
    emp1.setProperty(propName, false);
    emp1.entityAspect.rejectChanges();
    const dc = emp1.getProperty(propName);
    expect(dc).toBe(false);

  });


  test("post create init 1", () => {
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.sampleMetadata));
    const Product = createProductCtor();
    const productType = em.metadataStore.getAsEntityType("Product");
    em.metadataStore.registerEntityTypeCtor("Product", Product, function (entity: Entity) {
      expect(entity.entityType).toBe(productType);
      expect(entity.getProperty("isObsolete")).toBe(false);
      entity.setProperty("isObsolete", true);
    });

    const product = productType.createEntity();
    expect(product.getProperty("isObsolete")).toBe(true);

    product.setProperty("isObsolete", false);
    expect(product.getProperty("isObsolete")).toBe(false);
  });

  test("post create init 2", () => {
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.sampleMetadata));
    const Product = createProductCtor();

    const productType = em.metadataStore.getAsEntityType("Product");
    em.metadataStore.registerEntityTypeCtor("Product", Product, "init");

    const product = productType.createEntity();
    expect(product.getProperty("isObsolete")).toBe(true);
  });

  test("post create init 3", () => {
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.sampleMetadata));
    const Product = createProductCtor();
    const productType = em.metadataStore.getAsEntityType("Product");
    em.metadataStore.registerEntityTypeCtor("Product", Product, "init");

    const product = productType.createEntity();
    expect(product.getProperty("isObsolete")).toBe(true);
  });

  test("post create init after new and attach", () => {
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.sampleMetadata));
    const Product = createProductCtor() as any;
    const product = new Product();
    const productType = em.metadataStore.getAsEntityType("Product");
    em.metadataStore.registerEntityTypeCtor("Product", Product, "init");
    em.attachEntity(product);

    expect(product.getProperty("isObsolete")).toBe(true);
  });

  test("graph attach (1-n) - setProperties child, attach child", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();

    order1.setProperty("customer", cust1);
    em.attachEntity(order1);
    expect(order1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Unchanged);
    const orders = cust1.getProperty("orders");
    expect(orders[0]).toBe(order1);
    expect(orders[0].getProperty("customer")).toBe(cust1);
  });

  test("graph attach (1-n)- setProperties child, attach parent", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();

    order1.setProperty("customer", cust1);
    em.attachEntity(cust1);
    expect(order1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Unchanged);
    const orders = cust1.getProperty("orders");
    expect(orders[0]).toBe(order1);
  });

  test("graph attach (1-n) - setProperties parent, attach parent", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();

    const cust1Orders = cust1.getProperty("orders");
    cust1Orders.push(order1);
    expect(cust1Orders.length).toBe(1);
    em.attachEntity(cust1);
    expect(order1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(order1.getProperty("customer")).toBe(cust1);
  });

  test("graph attach (1-n) - setProperties parent, attach child", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();

    const cust1Orders = cust1.getProperty("orders");
    cust1Orders.push(order1);
    expect(cust1Orders.length).toBe(1);
    em.attachEntity(order1);
    expect(order1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(order1.getProperty("customer")).toBe(cust1);
  });

  test("graph attach (1-n) - parent detach", () => {
    const em = TestFns.newEntityManager();
    const custType = em.metadataStore.getAsEntityType("Customer");
    const orderType = em.metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    const order1 = orderType.createEntity();

    const cust1Orders = cust1.getProperty("orders");
    cust1Orders.push(order1);
    expect(cust1Orders.length).toBe(1);
    em.attachEntity(order1);
    expect(order1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(cust1.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(order1.getProperty("customer")).toBe(cust1);
    const orderCustId = order1.getProperty(TestFns.wellKnownData.keyNames.customer);
    em.detachEntity(cust1);
    expect(cust1.entityAspect.entityState.isDetached());
    expect(order1.entityAspect.entityState.isUnchanged());
    const orderCustId2 = order1.getProperty(TestFns.wellKnownData.keyNames.customer);
    expect(orderCustId).toBe(orderCustId2);
  });


  test("graph attach (1-n) - piecewise", function () {
    const em = TestFns.newEntityManager();
    const orderType = em.metadataStore.getAsEntityType("Order");
    const orderDetailType = em.metadataStore.getAsEntityType("OrderDetail");

    const order = orderType.createEntity();
    expect(order.entityAspect.entityState.isDetached()).toBe(true);

    order.setProperty("orderID", 888);

    em.attachEntity(order);
    const orderId = order.getProperty("orderID");
    expect(orderId);
    expect(order.entityAspect.entityState.isUnchanged()).toBe(true);
    for (let i = 0; i < 3; i++) {
      const od = orderDetailType.createEntity();
      od.setProperty("productID", i + 1); // part of pk && not the default value
      order.getProperty("orderDetails").push(od);
      expect(od.entityAspect.entityState.isAdded()).toBe(true);
      expect(od.getProperty("order")).toBe(order);
      expect(od.getProperty("orderID")).toBe(orderId);
    }
  });

  // TODO: will not yet work if both order and orderDetail keys are autogenerated.

  test("graph attach (1-n)- all together", function () {
    const em = TestFns.newEntityManager();
    const orderType = em.metadataStore.getAsEntityType("Order");
    const orderDetailType = em.metadataStore.getAsEntityType("OrderDetail");

    const order = orderType.createEntity();
    expect(order.entityAspect.entityState.isDetached()).toBe(true);
    order.setProperty("orderID", 999);

    for (let i = 0; i < 3; i++) {
      const od = orderDetailType.createEntity();
      od.setProperty("productID", i + 1); // part of pk and not the default value
      order.getProperty("orderDetails").push(od);
      expect(od.entityAspect.entityState.isDetached()).toBe(true);
    }
    em.attachEntity(order);
    const orderId = order.getProperty("orderID");
    expect(orderId);
    expect(order.entityAspect.entityState.isUnchanged()).toBe(true);
    order.getProperty("orderDetails").forEach((od: Entity) => {
      expect(od.getProperty("order")).toBe(order);
      expect(od.getProperty("orderID")).toBe(orderId);
      expect(od.entityAspect.entityState.isUnchanged()).toBe(true);
    });
  });

  test("graph attach (1-n) - all together - autogenerated", function () {
    const em = TestFns.newEntityManager();
    const orderType = em.metadataStore.getAsEntityType("Order");
    const orderDetailType = em.metadataStore.getAsEntityType("OrderDetail");

    const order = orderType.createEntity();
    expect(order.entityAspect.entityState.isDetached()).toBe(true);
    order.setProperty("orderID", 999);

    for (let i = 0; i < 3; i++) {
      const od = orderDetailType.createEntity();
      od.setProperty("productID", i); // part of pk
      order.getProperty("orderDetails").push(od);
      expect(od.entityAspect.entityState.isDetached()).toBe(true);
    }
    em.attachEntity(order);
    expect(order.entityAspect.entityState.isUnchanged()).toBe(true);
    const orderId = order.getProperty("orderID");
    expect(orderId);
    order.getProperty("orderDetails").forEach( (od: Entity) => {
      expect(od.getProperty("order")).toBe(order);
      expect(od.getProperty("orderID")).toBe(orderId);
      expect(od.entityAspect.entityState.isUnchanged()).toBe(true);
    });
  });


  test("infer unmapped boolean datatype", () => {
    const em = TestFns.newEntityManager();
    const Customer = function () {
      // testContext.isBeingEdited = false;
    };
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const customerType = em.metadataStore.getAsEntityType("Customer");
    const unmapped = customerType.unmappedProperties[0];
    expect(unmapped.dataType).toBe(DataType.Boolean);
  });

    // const Customer = function () {
  //   this.miscData = "asdf";
  //   this.getNameLength = function () {
  //     return (this.getProperty("companyName") || "").length;
  //   };
  // };

  class Customer {
    miscData: string;
    constructor() {
      this.miscData = "asdf";
    }

    getNameLength() {
      return ((this as any).getProperty("companyName") || "").length;
    }
  }

  function createCustomer(em: EntityManager) {
    const custType = em.metadataStore.getAsEntityType("Customer");
    const cust = custType.createEntity();
    em.addEntity(cust);
    cust.setProperty("companyName", "TestXXX");
    return cust;
  }
  
  function createProductCtor() {
    const init = function (entity: Entity) {
      expect(entity.entityType.shortName).toBe("Product");
      expect(entity.getProperty("isObsolete")).toBe(false);
      entity.setProperty("isObsolete", true);
    };
    return function () {
      this.isObsolete = false;
      this.init = init;
    };

  }


});

