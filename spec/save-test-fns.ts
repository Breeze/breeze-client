import { EntityManager, AutoGeneratedKeyType, Entity, Predicate, FilterQueryOp, EntityQuery, SaveOptions, MetadataStore } from 'breeze-client';
import { TestFns, JsonObj } from './test-fns';
import { notDeepEqual } from 'assert';
import { startWith } from 'rxjs/operators';

export class SaveTestFns {

  static newEntityManager() {
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const testMs = em.metadataStore;
    const regionType = testMs.getAsEntityType("Region");
    regionType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
    const territoryType = testMs.getEntityType("Territory");
    territoryType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
    return em;
  }

  static async cleanup() {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const p = Predicate.create("companyName", FilterQueryOp.StartsWith, "Test")
      .or("companyName", FilterQueryOp.StartsWith, "foo");
    const q = EntityQuery.from("Customers").where(p).expand("orders"); // .take(50);
    const qr1 = await em.executeQuery(q);
    qr1.results.forEach(function (cust) {
      const orders = cust.getProperty("orders").slice(0);
      orders.forEach(function (order: Entity) {
        order.entityAspect.setDeleted();
      });
      cust.entityAspect.setDeleted();
    });

    const p2 = Predicate.create('lastName', FilterQueryOp.StartsWith, 'Test')
      .and('firstName', FilterQueryOp.StartsWith, 'Test');
    const qr2 = await EntityQuery.from('Employees').where(p2).using(em).execute();
    qr2.results.forEach(function (emp: Entity) {
      emp.entityAspect.setDeleted();
    });

    em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    try {
      const sr = await em.saveChanges();
    } catch (e) {
      // Eat the error because letting it go kills the test suite
      console.log(e);
    }
    // expect(sr.entities.length).not.toBeNull();
  }

  static getWierdCustomerCtor() {
    const ctor = function () {
      this.myUnmappedProperty = "anything22";
      const x: JsonObj = {
        x: "22",
        y: "test",
        z: ["a1", 3, true, null, undefined, { foo: 4 }, function (x: any, y: any, z: any) {
          return 666;
        }],
        testFn: function (a: any, b: any) {
          return a + b;
        }
      };
      x.recursive = { ok: true, notOk: x }; // notOk should not get serialized.
      this.anotherOne = x;
    };
    return ctor;
  }

  static createCustomer(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    return cust1;
  }

  static async saveNewCustAndOrders(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const orderType = metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    const order1 = orderType.createEntity();
    order1.setProperty("orderDate", new Date());
    const order2 = orderType.createEntity();
    const orders = cust1.getProperty("orders");
    order2.setProperty("orderDate", new Date());
    orders.push(order1);
    orders.push(order2);
    const sr1 = await em.saveChanges();
    expect(cust1.entityAspect.entityState.isUnchanged());
    return cust1;
  }

  static createParentAndChildren(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const orderType = metadataStore.getAsEntityType("Order");
    const orderKeyName = TestFns.wellKnownData.keyNames.order;
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    const cust2 = custType.createEntity();
    cust2.setProperty("companyName", "Test_js_2");
    cust2.setProperty("city", "Emeryville");
    cust2.setProperty("rowVersion", 1);
    cust2.setProperty("fax", "510 888-8888");
    em.addEntity(cust1);
    em.addEntity(cust2);
    const order1 = orderType.createEntity();
    order1.setProperty("orderDate", new Date());
    const order2 = orderType.createEntity();
    const orders = cust1.getProperty("orders");
    order2.setProperty("orderDate", new Date());
    orders.push(order1);
    orders.push(order2);
    const keyValues = [cust1.getProperty(customerKeyName),
    cust2.getProperty(customerKeyName),
    order1.getProperty(orderKeyName),
    order2.getProperty(orderKeyName)];
    return {
      cust1: cust1,
      cust2: cust2,
      order1: order1,
      order2: order2,
      keyValues: keyValues
    };
  }

  static createParentAndManyChildren(em: EntityManager) {
    const metadataStore = em.metadataStore;
    const custType = metadataStore.getAsEntityType("Customer");
    const orderType = metadataStore.getAsEntityType("Order");
    const cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    const orders = cust1.getProperty("orders");
    for (let i = 1; i < 50; i++) {
      const order1 = orderType.createEntity();
      order1.setProperty("shipRegion", "foo-region");
      orders.push(order1);
    }
  }

  static createOrder(em: EntityManager) {
    const orderType = em.metadataStore.getAsEntityType("Order");
    const order = orderType.createEntity();
    em.addEntity(order);
    order.setProperty("shipName", "Test_" + new Date().toDateString());
    return order;
  }

  static createProduct(em: EntityManager) {
    const productType = em.metadataStore.getAsEntityType("Product");
    const product = productType.createEntity();
    em.addEntity(product);
    product.setProperty("productName", "Test_" + new Date().toDateString());
    return product;
  }

  static createOrderDetail(em: EntityManager, order: Entity, product: Entity) {
    const odType = em.metadataStore.getAsEntityType("OrderDetail");
    const od = odType.createEntity();
    const orderID = order.getProperty("orderID");
    const productID = product.getProperty("productID");

    od.setProperty("orderID", orderID);
    od.setProperty("productID", productID);
    od.setProperty("quantity", 1);
    od.setProperty("unitPrice", 3.14);
    em.addEntity(od);
    return od;
  }

  static createRegion(em: EntityManager, descr: string) {
    const regionType = em.metadataStore.getAsEntityType("Region");
    const region = regionType.createEntity();

    region.setProperty("regionDescription", "Test-" + descr + "-" + new Date().toDateString());
    em.addEntity(region);
    return region;
  }

  static createTerritory(em: EntityManager, descr: string) {
    const territoryType = em.metadataStore.getAsEntityType("Territory");
    const territory = territoryType.createEntity();
    territory.setProperty("territoryDescription", "Test-" + descr + "-" + new Date().toDateString());
    em.addEntity(territory);
    return territory;
  }



}

