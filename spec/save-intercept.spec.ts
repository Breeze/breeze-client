
import { Entity, EntityQuery, EntityType, MetadataStore, EntityChangedEventArgs, EntityAction, MergeStrategy, QueryOptions, FetchStrategy, EntityManager, EntityAspect, Predicate, SaveOptions, EntityProperty, EntityState, AutoGeneratedKeyType, HasChangesChangedEventArgs, core, RelationArray, FilterQueryOp, AbstractDataServiceAdapter, breeze, SaveContext, SaveBundle, ChangeRequestInterceptor } from 'breeze-client';
import { TestFns, JsonObj, skipTestIf } from './test-fns';
import { SaveTestFns } from './save-test-fns';

TestFns.initServerEnv();
// get active dataService adapter
const dsAdapter = <AbstractDataServiceAdapter> breeze.config.getAdapterInstance('dataService');

beforeAll(async () => {
  await TestFns.initDefaultMetadataStore();
});

afterAll(async () => {
  await SaveTestFns.cleanup();
});

describe("Save Basics", () => {

  beforeEach(() => {
    delete dsAdapter.changeRequestInterceptor;
  });

  afterEach(() => {
    // removing any lingering, instance-level ChangeRequestInterceptor
    // left behind by some outside test that forgot to cleanup.
    // The prototype-level interceptor is untouched.
    delete dsAdapter.changeRequestInterceptor;
  });


  test('Default interceptor, no harm', async () => {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const nancy = await getNancy(em);
    tweakEmp(nancy);
    const result = await em.saveChanges();
    expect(result.entities.length).toBe(1);
  });

  test('NULL interceptor, no harm', async () => {
    expect.hasAssertions();
    dsAdapter.changeRequestInterceptor = null;
    const em = TestFns.newEntityManager();
    const nancy = await getNancy(em);
    tweakEmp(nancy);
    const result = await em.saveChanges();
    expect(result.entities.length).toBe(1);
  });

  test('poison interceptor, should fail', async () => {
    expect.hasAssertions();
    dsAdapter.changeRequestInterceptor = PoisonInterceptor;
    const em = TestFns.newEntityManager();
    const nancy = await getNancy(em);
    tweakEmp(nancy);
    try {
      const result = await em.saveChanges();
      throw new Error('should not get here');
    } catch (e) {
      expect(e.message).toMatch(/Poison interceptor/);
    }
    
  });

  test('interceptor members called with expected values', async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    let nancy: Entity;
    let wasCalled = false;

    // simple enough for all dataservice adapters
    // Normally would be constructed as a Clas with constructor, getRequest, and done methods
    // but this allows us to use values from the outside closure.
    dsAdapter.changeRequestInterceptor = <any> function (saveContext: SaveContext, saveBundle: SaveBundle) {

      expect(saveContext.entityManager === em).toBeTrue();
      expect(saveBundle.saveOptions).toBeTruthy();

      this.getRequest = function (request: any, entity: Entity, index: number) {
        expect(request).toBeTruthy();
        expect(entity === nancy).toBeTrue();
        expect(index).toBe(0);

        if (TestFns.isODataServer) {
          const headers = request && request.headers;
          expect(headers).toBeTruthy();
        } else {
          const aspect = request && request.entityAspect;
          expect(aspect).toBeTruthy();
          const origValues = aspect && aspect.originalValuesMap;
          expect(origValues).toBeTruthy();
        }
        return request;
      };

      this.done = function (requests: Object[]) {
        expect(Array.isArray(requests)).toBeTrue();
        expect(requests && requests.length).toBe(1);
        wasCalled = true;
      };
    };

    try {
      nancy = await getNancy(em);
      tweakEmp(nancy);
      await em.saveChanges();
      expect(wasCalled).toBeTrue();
    } finally {
      // poison this adapter's interceptor to prove test module always clears it
      dsAdapter.changeRequestInterceptor = <any> PoisonInterceptor;
    }
  });


  
  ////// helpers ///////

  function createOrder(em: EntityManager) {
    return em.createEntity("Order", {
      shipName: "Test_" + new Date().toDateString()
    });
  }

  function createProduct(em: EntityManager) {
    return em.createEntity("Product", {
      productName: "Test_" + new Date().toDateString()
    });
  }

  async function getNancy(em: EntityManager) {
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;
    const data = await EntityQuery.from("Employees")
      .where(employeeKeyName, "eq", TestFns.wellKnownData.nancyID)
      .using(em).execute();
    return data.results[0];
  }

  class PoisonInterceptor implements ChangeRequestInterceptor {

    constructor (saveContext: SaveContext, saveBundle: SaveBundle) {
      throw new Error("Poison interceptor 'constructor' called.");
    }

    getRequest (request: any, entity: Entity, index: number) {
      throw new Error("Poison interceptor 'done' called.");
    }

    done(requests: Object[]) {
      throw new Error("Poison interceptor 'done' called.");
    }
    
  }  

  function tweakEmp(emp: Entity, baseToc?: string) {
    baseToc = baseToc || 'Ms.';
    const prop = 'titleOfCourtesy';
    const toc = emp.getProperty(prop);
    // toggle toc to make an innocuous saveable change
    emp.setProperty(prop, toc === baseToc ? 'Dr.' : baseToc);
  }

});