import { Entity, EntityQuery, EntityType, MetadataStore, EntityChangedEventArgs, EntityAction, MergeStrategy, QueryOptions, FetchStrategy, EntityManager, EntityAspect, Predicate, SaveOptions, EntityProperty, EntityState, AutoGeneratedKeyType, HasChangesChangedEventArgs, core, RelationArray, FilterQueryOp } from 'breeze-client';
import { TestFns, JsonObj, skipTestIf } from './test-fns';
import { SaveTestFns } from './save-test-fns';

TestFns.initServerEnv();

beforeAll(async () => {
  await TestFns.initDefaultMetadataStore();
});

afterAll( async () => {
  await SaveTestFns.cleanup();
});

describe("Save Basics", () => {

  beforeEach(function () {

  });

  test("update with client concurrency update with null rowVersion", async () => {
    expect.hasAssertions();
    let cust: Entity, rowVersion: number;
    const em1 = TestFns.newEntityManager();

    const q1 = new EntityQuery("Customers").where("rowVersion", "==", null).take(1);
    const data = await em1.executeQuery(q1);
    cust = data.results[0];
    TestFns.morphStringProp(cust, "contactName");
    rowVersion = cust.getProperty("rowVersion");
    const sr = await em1.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    expect(cust.getProperty("rowVersion")).toBe(rowVersion + 1);
  });

  test("update with client concurrency update with non-null rowVersion", async function () {
    expect.hasAssertions();
    
    const em1 = TestFns.newEntityManager();

    const qr1 = await em1.executeQuery(new EntityQuery("Customers")
      .where("rowVersion", "!=", null)
      .where("companyName", "!=", "error")
      .take(1));
    const cust = qr1.results[0];
    TestFns.morphStringProp(cust, "contactName");
    const rowVersion = cust.getProperty("rowVersion");
    const sr = await em1.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    expect(cust.getProperty("rowVersion")).toBe(rowVersion + 1);
  });

  test("update order", async () => {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("customerID", "!=", null).take(1);
    const qr1 = await em.executeQuery(q);
    const orders = qr1.results;
    expect(orders.length).toBe(1);
    const order = orders[0];
    const customerId = order.getProperty("customerID");
    const freight = order.getProperty("freight");
    const offset = (Math.random() * 2 | 0) ? 0.01 : -0.01;
    order.setProperty("freight", freight + offset);
    const sr = await em.saveChanges();
    const entities = sr.entities;
    expect(entities.length).toBe(1);
    expect(entities[0]).toBe(order);
    expect(order.getProperty("customerID")).not.toBeNull;
  });

  test("insert multipart entity", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const product = SaveTestFns.createProduct(em);
    const order = SaveTestFns.createOrder(em);
    const sr0 = await em.saveChanges();

    expect(sr0.entities.length).toBe(2);
    const orderDetail = SaveTestFns.createOrderDetail(em, order, product);
    const orderID = order.getProperty("orderID");
    const productID = product.getProperty("productID");
    expect(orderID).not.toBe(0);
    expect(productID).not.toBe(0);
    const odOrderID_1 = orderDetail.getProperty("orderID");
    const odProductID_1 = orderDetail.getProperty("productID");
    expect(orderID).toBe(odOrderID_1);
    expect(productID).toBe(odProductID_1);
    const sr = await em.saveChanges();

    expect(sr.entities.length).toBe(1);
    const orderIDx = order.getProperty("orderID");
    const productIDx = product.getProperty("productID");
    // expect(orderID).not.toBe(orderIDx, "orderID should have changed");
    // expect(productID).not.toBe(productIDx, "productID should have changed");
    const odOrderIDx = orderDetail.getProperty("orderID");
    const odProductIDx = orderDetail.getProperty("productID");
    expect(orderIDx).toBe(odOrderIDx);
    expect(productIDx).toBe(odProductIDx);
    // hack should not be necessary.
    // orderDetail.setProperty("productID", productIDx);
    orderDetail.setProperty("unitPrice", 10);
    const sr2 = await em.saveChanges();

    expect(sr2.entities.length).toBe(1);
  });

  // bug is with fixup of the 2nd part of the pk
  test("insert multipart entity 2", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const order = SaveTestFns.createOrder(em);
    const product = SaveTestFns.createProduct(em);
    const orderDetail = SaveTestFns.createOrderDetail(em, order, product);

    const orderID = order.getProperty("orderID");
    const productID = product.getProperty("productID");
    expect(orderID).not.toBe(0);
    expect(productID).not.toBe(0);
    const odOrderID = orderDetail.getProperty("orderID");
    const odProductID = orderDetail.getProperty("productID");
    expect(orderID).toBe(odOrderID);
    expect(productID).toBe(odProductID);

    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(3);
    expect(sr.entities).toContain(product);
    expect(sr.entities).toContain(order);
    expect(sr.entities).toContain(orderDetail);
    const orderIDx = order.getProperty("orderID");
    const productIDx = product.getProperty("productID");
    expect(orderID).not.toBe(orderIDx);
    expect(productID).not.toBe(productIDx);
    const odOrderIDx = orderDetail.getProperty("orderID");
    const odProductIDx = orderDetail.getProperty("productID");
    expect(orderIDx).toBe(odOrderIDx);
    expect(productIDx).toBe(odProductIDx);
    // hack should not be necessary.
    // orderDetail.setProperty("productID", productIDx);
    orderDetail.setProperty("unitPrice", 10);
    const sr2 = await em.saveChanges();
    expect(sr2.entities.length).toBe(1);

  });

  test("hasChangesChanged event raised after saveChanges", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();

    let hasChangesChangedRaised: boolean[] = [];
    em.hasChangesChanged.subscribe(
      function (eventArgs) {
        hasChangesChangedRaised.push(eventArgs.hasChanges);
      }
    );

    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");


    await em.saveChanges();
    expect(hasChangesChangedRaised.length).toBe(2);
    expect(hasChangesChangedRaised[0]).toBe(true);
    expect(hasChangesChangedRaised[1]).toBe(false);
    expect(em.hasChanges()).toBe(false);
  });

  
  test("delete without query", async function () {
    expect.hasAssertions();
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;
    const em = TestFns.newEntityManager();
    const em2 = TestFns.newEntityManager();
    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);

    let similarEmp: Entity, similarAspect: EntityAspect;
    const sr = await em.saveChanges();
    const savedEnts = sr.entities;
    expect(savedEnts.length).toBe(1);
    expect(emp).toBe(savedEnts[0]);
    const empKeyValue = emp.getProperty(employeeKeyName);
    const empKey = emp.entityAspect.getKey();
    const empVersion = emp.getProperty("rowVersion");
    similarEmp = em2.createEntity("Employee");
    similarEmp.setProperty(employeeKeyName, empKeyValue);
    similarEmp.setProperty("rowVersion", empVersion);
    similarAspect = similarEmp.entityAspect;
    similarAspect.setUnchanged();
    similarAspect.setDeleted();
    expect(similarAspect.entityState.isDeleted()).toBe(true);
    const sr2 = await em2.saveChanges();
    const savedEnts2 = sr2.entities;
    expect(savedEnts2.length).toBe(1);
    expect(savedEnts2[0]).toBe(similarEmp);
    expect(similarAspect.entityState.isDetached()).toBe(true);
  });

  test("pk update should throw meaningful exception", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Territories").orderBy("territoryID desc").take(1);

    try {
      const qr1 = await q.using(em).execute();
      expect(qr1.results.length).toBe(1);
      const terr = qr1.results[0];
      const id = terr.getProperty("territoryID");
      terr.setProperty("territoryID", id + 1);
      const sr = await em.saveChanges();
      throw 'should not get here';
    } catch (e) {
      const msg = e.message.toLowerCase();
      if (TestFns.isHibernateServer) {
        expect(msg).toMatch(/row was updated or deleted by another/);
      }
      else if (TestFns.isAspCoreServer) {
        expect(msg).toMatch(/data may have been modified or/);
      }
      else {
        expect(msg).toMatch(/part of the entity's key/);
      }
      
    }
  });

  
  test("product update active", async function () {
    expect.assertions(2);
    await updateProduct(4);
  });

  
  test("product update discontinued", async function () {
    expect.assertions(2);
    await updateProduct(5);
  });

  async function updateProduct(productId: number) {

    const em = TestFns.newEntityManager();

    const q = new EntityQuery("Products").where("productID", "eq", productId);

    
    const qr1 = await q.using(em).execute();
    expect(qr1.results.length).toBe(1);
    const product = qr1.results[0];
    const unitsInStock = product.getProperty("unitsInStock");
    product.setProperty("unitsInStock", unitsInStock + 10);
    const sr1 = await em.saveChanges();
    expect(true).toBe(true);
  }

  // Unable to negate an expression that requires a Sequelize 'include'
  skipTestIf(TestFns.isSequelizeServer, 
    "add entity with enum and related - UserRole", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const userId = 6;
    //const p2 = breeze.Predicate.create("userId", "ne", userId);
    //const p1 = breeze.Predicate.create("userRoles", "all", p2);
    const p2 = Predicate.create("userId", "==", userId);
    const p1 = Predicate.create("userRoles", "any", p2).not();

    const q = new EntityQuery("Roles").where(p1).take(1);
    const data = await q.using(em).execute();
    expect(data.results.length).toBe(1);
    const role = data.results[0];
    const roleId = role.getProperty("id");
    const newUserRole = em.createEntity('UserRole', {
      userId: userId,
      roleId: roleId
    });
    const sr = await em.saveChanges();
    const resultRole = sr.entities[0];
    const roleId2 = resultRole.getProperty("roleId");
    expect(roleId2).toBe(roleId);
    const userId2 = resultRole.getProperty("userId");
    expect(userId2).toBe(userId);
    // delete entity
    resultRole.entityAspect.setDeleted();
    await em.saveChanges();
    
  });

  // don't yet support enums
  skipTestIf(TestFns.isSequelizeServer || TestFns.isODataServer,
    "new entity with enum", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const em2 = TestFns.newEntityManager();
    const roleType = em.metadataStore.getEntityType("Role");

    const aRole = em.createEntity("Role");
    aRole.setProperty("roleType", "Restricted");
    aRole.setProperty("name", "TEMP" + TestFns.makeTempString(5));
    const ves = aRole.entityAspect.validateEntity();
    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(1);
    aRole.setProperty("roleType", "Guest");
    const sr2 = await em.saveChanges();
    expect(sr2.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(aRole);
    const data = await em2.executeQuery(q2);
    const roles = data.results;
    expect(roles.length).toBe(1);
    const aRole2 = roles[0];
    const rt = aRole2.getProperty("roleType");
    expect(rt).toBe("Guest");
    // throw away 'set' because the object is going to be deleted anyway.
    aRole2.setProperty("roleType", "Restricted");
    aRole2.entityAspect.setDeleted();
    const sr3 = await em2.saveChanges();
    expect(sr3.entities.length).toBe(1);
    expect(aRole2.entityAspect.entityState.isDetached()).toBe(true);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("exceptions thrown on server", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").take(1);

    try {
      const data = await q.using(em).execute();
      const order = data.results[0];
      const freight = order.getProperty("freight") + 0.5;
      order.setProperty("freight", freight);
      const so = new SaveOptions({ resourceName: "SaveAndThrow", tag: "SaveAndThrow" });
      const sr = await em.saveChanges(null, so);
      throw new Error("should not get here");
    } catch (e) {
      expect(e).toBeTruthy();
    }
  });

  test("delete entity with Int32 property set to null", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const c1 = em.createEntity("Order", { employeeID: 1 });
    const employeeKeyName = TestFns.wellKnownData.keyNames.employee;

    //save entity with non-null value on Int32 field
    const sr = await em.saveChanges();
    const order = sr.entities[0];
    const empId0 = order.getProperty(employeeKeyName);
    expect(empId0).not.toBeNull();
    //set the Int32 field to null
    order.setProperty(employeeKeyName, null);
    const sr1 = await em.saveChanges();
    const order1 = sr1.entities[0];
    const empId1 = order1.getProperty(employeeKeyName);
    expect(empId1).toBeNull();
    //mark entity as deleted
    order1.entityAspect.setDeleted();
    await em.saveChanges();
    
  });

  
  test("check unmapped property on server", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const customerType = em.metadataStore.getAsEntityType("Customer");

    const Customer = function () {
      this.myUnmappedProperty = "anything22";
    };
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    const entitiesToSave = new Array(cust);
    const saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedProperty" });

    await em.saveChanges(entitiesToSave, saveOptions);
    expect(true).toBe(true);
  });

  
  test("unmapped property serialization on server", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const customerType = em.metadataStore.getAsEntityType("Customer");
    customerType.setProperties({
      serializerFn: function (dp: EntityProperty, value: any) {
        if (typeof (value) === "string") return value.toUpperCase();
        if (dp.isUnmapped) {
          if (dp.name === "anotherOne") {
            value.extra = 666;
          }
        }
        return value;
      }
    });
    const Customer = SaveTestFns.getWierdCustomerCtor();
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    const entitiesToSave = new Array(cust);
    const saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedPropertySerialized" });


    const sr = await em.saveChanges(entitiesToSave, saveOptions);
    expect(true).toBe(true);
  });

  test("unmapped property suppression", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const customerType = em.metadataStore.getAsEntityType("Customer");
    customerType.setProperties({
      serializerFn: function (dp, value) {
        if (dp.isUnmapped) return undefined;
        return value;
      }
    });
    const Customer = SaveTestFns.getWierdCustomerCtor();
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);


    const cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    const entitiesToSave = new Array(cust);
    const saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedPropertySuppressed" });

    await em.saveChanges(entitiesToSave, saveOptions);
    expect(true).toBe(true);
  });

  test("check initializer is hit for entities added/saved on server", async function () {
    expect.assertions(2);
    const em = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const ordInitializer = function (ord: Entity) {
      ord.setProperty("shipCountry", "Brazil");
    };

    em.metadataStore.registerEntityTypeCtor("Order", null, ordInitializer);

    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);
    const so = new SaveOptions({ resourceName: "SaveCheckInitializer" });

    const sr = await em.saveChanges(null, so);
    const ents = sr.entities;
    expect(ents.length).toBe(2);
    ents.forEach(function (ent) {
      if (ent.entityType.shortName === "Order") {
        expect(ent.getProperty("shipCountry")).toBe("Brazil");
      }
    });
  });

  // //TestFns.skipIf("odata", "does not support server side interception or alt resource").
  test("entities retrieved on server being modified and resaved", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();

    const q = EntityQuery.from("Categories").where("categoryName", "startsWith", "Beverage");

    const data = await em.executeQuery(q);
    const category = data.results[0];
    TestFns.morphStringProp(category, "categoryName");
    const entitiesToSave = new Array(category);
    const saveOptions = new SaveOptions({ tag: "increaseProductPrice" });
    const sr = await em.saveChanges(entitiesToSave, saveOptions);
    expect(sr.entities.length).toBe(13);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("data with additional entity added on server", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();

    const supplier = em.createEntity("Supplier", { companyName: "CompName" });
    const entitiesToSave = new Array(supplier);
    const saveOptions = new SaveOptions({ tag: "addProdOnServer" });

    const sr = await em.saveChanges(entitiesToSave, saveOptions);
    const addedProducts = em.getEntities(["Product"], EntityState.Added);
    expect(addedProducts.length).toBe(0);
  });


  test("can save a Northwind Order & InternationalOrder", async function () {
    expect.hasAssertions();

    // Create and initialize entity to save
    const em = TestFns.newEntityManager();

    const order = em.createEntity('Order', {
      customerID: TestFns.wellKnownData.alfredsID,
      employeeID: TestFns.wellKnownData.nancyID,
      shipName: "Test " + new Date().toISOString()
    });

    const internationalOrder = em.createEntity('InternationalOrder', {
      // I thought Jay fixed this?
      order: order, // sets OrderID and pulls it into the order's manager
      // orderID: order.getProperty("orderID"),
      customsDescription: "rare, exotic birds"
    });

    const data = await em.saveChanges();
    const orderId = order.getProperty("orderID");
    const internationalOrderID = internationalOrder.getProperty("orderID");
    expect(internationalOrderID).toBe(orderId);
    expect(orderId).toBeGreaterThan(0);
  });

  test("can save a Northwind Order & OrderDetail", async function () {
    expect.hasAssertions();

    // Create and initialize entity to save
    const em = TestFns.newEntityManager();

    const order = em.createEntity('Order', {
      customerID: TestFns.wellKnownData.alfredsID,
      employeeID: TestFns.wellKnownData.nancyID,
      shipName: "Test " + new Date().toISOString()
    });

    const orderDetail1 = em.createEntity('OrderDetail', {
      order: order, // sets OrderID and pulls it into the order's manager
      productID: TestFns.wellKnownData.chaiProductID, 
      quantity: 5
    });
    const orderDetail2 = em.createEntity('OrderDetail', {
      order: order, // sets OrderID and pulls it into the order's manager
      productID: TestFns.wellKnownData.alfredsOrderDetailKey.productID,
      quantity: 6
    });

    const data = await em.saveChanges();
    const orderId = order.getProperty("orderID");
    expect(orderId).toBeGreaterThan(0);

  });


  test("save with date as part of key", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const dt = new Date();
    dt.setUTCMilliseconds(100);
    const c1 = em.createEntity("Comment", { createdOn: dt, seqNum: 1, comment1: "now is the time for" });
    const c2 = em.createEntity("Comment", { createdOn: dt, seqNum: 2, comment1: "and again" });

    const sr = await em.saveChanges();
    const comments = sr.entities;
    expect(comments.length).toBe(2);
    const em2 = TestFns.newEntityManager();
    const q = EntityQuery.from("Comments").where("createdOn", "==", dt);
    const data = await em2.executeQuery(q);
    const comments2 = data.results;
    expect(comments2.length).toBe(2);
  });

  // does not yet support computed properties
  skipTestIf(TestFns.isSequelizeServer || TestFns.isHibernateServer,
   "computed update", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const q = EntityQuery.from("Employees").take(3);

    const data = await em.executeQuery(q);
    const emps = data.results;
    TestFns.morphStringProp(emps[0], "lastName");
    const sr = await em.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    const emp = ents[0];
    const fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
    if (TestFns.isODataServer) {
      // fullNames will not match with ODATA because no records are returned after save;
      expect(fullName !== emp.getProperty("fullName")).toBe(true);
    } else {
      expect(fullName).toBe(emp.getProperty("fullName"));
    }
  });

  // does not yet support computed properties
  skipTestIf(TestFns.isSequelizeServer || TestFns.isHibernateServer,
    "computed update - mod computed", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const q = EntityQuery.from("Employees").take(3);

    const data = await em.executeQuery(q);
    const emps = data.results;
    TestFns.morphStringProp(emps[0], "lastName");
    emps[0].setProperty("fullName", "xxx");
    const sr = await em.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    const emp = ents[0];
    const fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
    if (TestFns.isODataServer) {
      // fullNames will not match with ODATA because no records are returned after save;
      expect(fullName !== emp.getProperty("fullName")).toBe(true);
    } else {
      expect(fullName).toBe(emp.getProperty("fullName"));
    }
  });

  // does not yet support computed properties
  skipTestIf(TestFns.isSequelizeServer || TestFns.isHibernateServer,
    "computed insert", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);

    const sr = await em.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
    expect(ents[0]).toBe(emp);
    const fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
    expect(fullName).toBe(emp.getProperty("fullName"));
  });

  test("update with unmapped changes", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = function () {
      this.miscData = "asdf";
    };
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const q = new EntityQuery("Customers").take(1);
    const qr1 = await em1.executeQuery(q);
    const custType = em1.metadataStore.getEntityType("Customer");
    const cust = qr1.results[0];
    const oldContactName = cust.getProperty("contactName");
    const oldMiscData = cust.getProperty("miscData");
    TestFns.morphStringProp(cust, "contactName");
    TestFns.morphStringProp(cust, "miscData");
    const sr = await em1.saveChanges();
    const e = sr.entities;
    expect(e.length).toBe(1);
  });

  // Test asserts will fail for OData until we fix #2574
  // "entityAspect.extraMetdata not preserved after export/import"
  test("update after exporting and reimporting a customer", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const q1 = new EntityQuery("Customers").take(1).using(em1);
    const qr1 = await q1.execute();
    let cust = qr1.results[0];
    let extraMetadata;
    if (TestFns.isODataServer) {
      extraMetadata = cust.entityAspect.extraMetadata;
      // has OData extraMetadata on the original customer before export
      expect(extraMetadata).toBeTruthy();
    }
    const exported = em1.exportEntities([cust], { includeMetadata: false }); // exclude metadata ... not important
    cust.entityAspect.setDetached(); // remove from cache
    cust = em1.importEntities(exported).entities[0]; // get reimported customer
    if (TestFns.isODataServer) {
      // these tests fail for OData until #2574 fixed
      const xtra = cust.entityAspect.extraMetadata;
      // has extraMetadata on the imported customer
      expect(xtra).toBeTruthy();
      expect(xtra.etag).toBe(extraMetadata.etag);
    }
    TestFns.morphStringProp(cust, "contactName");
    const sr = await em1.saveChanges();
    const ents = sr.entities;
    expect(ents.length).toBe(1);
  });

  test("update with ES5 props and unmapped changes", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = TestFns.getCustomerWithES5PropsCtor();
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const q = new EntityQuery("Customers").take(1);
    const qr1 = await em1.executeQuery(q);
    const custType = em1.metadataStore.getEntityType("Customer");
    const cust = qr1.results[0];
    const oldContactName = cust.getProperty("contactName");
    const oldMiscData = cust.getProperty("miscData");
    TestFns.morphStringProp(cust, "contactName");
    TestFns.morphStringProp(cust, "miscData");
    const sr = await em1.saveChanges();
    const e = sr.entities;
    expect(e.length).toBe(1);
  });

  test("delete with unmapped changes", async function () {
    expect.hasAssertions();
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = function () {
      this.miscData = "asdf";
    };
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);
    
    // await em1.fetchMetadata();
    const zzz = SaveTestFns.createParentAndChildren(em1);
    const saveResult = await em1.saveChanges();
    const cust = zzz.cust1;
    const oldContactName = cust.getProperty("contactName");
    const oldMiscData = cust.getProperty("miscData");
    TestFns.morphStringProp(cust, "contactName");
    TestFns.morphStringProp(cust, "miscData");
    zzz.cust1.entityAspect.setDeleted();
    const sr = await em1.saveChanges();
    const r = sr.entities;
    expect(zzz.cust1.entityAspect.entityState.isDetached());
    expect(r.length).toBe(3);

  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with server reject", async function () {
    expect.hasAssertions();

    const em = SaveTestFns.newEntityManager();

    const user = em.createEntity("Region");

    user.setProperty("regionDescription", "error here");
    em.addEntity(user);
    let hasChanges = em.hasChanges();
    expect(hasChanges).toBe(true);

    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(0);
    hasChanges = em.hasChanges();
    expect(hasChanges).toBe(true);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  // Sequelize server has not yet impl SaveWithAuditXXX
  skipTestIf(TestFns.isSequelizeServer || TestFns.isODataServer, 
    "set audit field on user create", async function () {
    expect.hasAssertions();

    const em = TestFns.newEntityManager();
    const user = em.createEntity("User");
    user.setProperty("userName", "Test" + Date.now());
    user.setProperty("userPassword", "" + Date.now());
    user.setProperty("firstName", "Test");
    user.setProperty("lastName", "Test");
    user.setProperty("email", "test@test.com");

    em.addEntity(user);
    const hasChanges = em.hasChanges();
    expect(hasChanges).toBe(true);
    const so = new SaveOptions({ resourceName: "SaveWithAuditFields" });

    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    sr.entities.forEach(function (e: any) {
      expect(e.createdByUserId).toBe(12345);
    });
  });

  test("user update", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Users").where("id", "eq", 4);
    
    const email = "u" + Date.now() + "@ideablade.com";
    const qr1 = await q.using(em).execute();
    const user = qr1.results[0];
    user.setProperty("email", email);
    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(1);
    sr.entities.forEach(function (e: any) {
      expect(e.email).toBe(email);
    });
  });


  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  // Sequelize server has not yet impl SaveWithAuditXXX
  skipTestIf(TestFns.isSequelizeServer || TestFns.isODataServer, 
    "set audit field on user update", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Users").where("id", "eq", 4);

    const data = await q.using(em).execute();
    const user = data.results[0];
    user.setProperty("email", "u" + Date.now() + "@ideablade.com");
    const so = new SaveOptions({ resourceName: "SaveWithAuditFields" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    sr.entities.forEach(function (e: any) {
      expect(e.modifiedByUserId).toBe(12345);
    });
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  // TODO: may fail in Sequelize because of side effect with other tests - not sure why
  test("with alt resource and server side add", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).take(1).orderBy("orderID", true);

    const qr1 = await q.using(em).execute();
    const order = qr1.results[0];
    const freight = order.getProperty("freight") + 0.5;
    order.setProperty("freight", freight);
    const so = new SaveOptions({ resourceName: "SaveWithComment", tag: "SaveWithComment - order" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(2);
    sr.entities.forEach(function (e) {
      expect(e.entityAspect).toBeTruthy();
    });
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server update", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(1).take(1).orderBy("orderID");

    const data = await q.using(em).execute();
    const order = data.results[0];
    const freight = order.getProperty("freight") + 0.5;
    order.setProperty("freight", freight);
    const so = new SaveOptions({ resourceName: "SaveWithFreight2", tag: "freight update" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight + 1);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server update - ForceUpdate", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(2).take(1).orderBy("orderID");


    const data = await q.using(em).execute();
    const order = data.results[0];
    const freight = order.getProperty("freight");
    const shipCountry = TestFns.morphString(order.getProperty("shipCountry"));
    order.setProperty("shipCountry", shipCountry);
    const so = new SaveOptions({ resourceName: "SaveWithFreight", tag: "freight update-force" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight + 1);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with server update - original values fixup", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(3).take(1).orderBy("orderID");

    const data = await q.using(em).execute();
    const order = data.results[0];
    const freight = order.getProperty("freight");
    const shipCity = TestFns.morphString(order.getProperty("shipCountry"));
    order.setProperty("shipCountry", shipCity);
    const so = new SaveOptions({ resourceName: "SaveWithFreight", tag: "freight update-ov" });
    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(1);
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em).execute();
    const order2 = data2.results[0];
    const freight2 = order2.getProperty("freight");
    expect(freight2).toBe(freight + 1);
  });

  //TestFns.skipIf("odata", "does not support server interception or alt resources").
  test("with saveOptions exit", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);
    const cust1 = zzz.cust1;
    const so = new SaveOptions({ resourceName: "SaveWithExit", tag: "exit" });

    const sr = await em.saveChanges(null, so);
    expect(sr.entities.length).toBe(0);
  });


  test("delete unsaved entity", async function () {
    expect.hasAssertions();
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const realEm = TestFns.newEntityManager();
    expect(realEm.hasChanges()).toBe(false);
    const query = EntityQuery.from("Customers")
      .where(customerKeyName, "==", "729de505-ea6d-4cdf-89f6-0360ad37bde7");
    
    const qr1 = await realEm.executeQuery(query);
    const cust = qr1.results[0];
    const data2 = cust.entityAspect.loadNavigationProperty("orders");
    const newOrder = realEm.createEntity("Order", {}, EntityState.Detached);
    const orders = cust.getProperty("orders");
    orders.push(newOrder);
    expect(newOrder.entityAspect.entityState.isAdded()).toBe(true);
    newOrder.entityAspect.setDeleted();
    expect(realEm.hasChanges()).toBe(false);
    const sr = await realEm.saveChanges();
    expect(realEm.hasChanges()).toBe(false);
  });

  test("bigsave", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    let recentArgs: HasChangesChangedEventArgs;
    em.hasChangesChanged.subscribe(function (args) {
      recentArgs = args;
    });
    for (let i = 0; i < 20; i++) {
      const zzz = SaveTestFns.createParentAndChildren(em);
    }
    expect(recentArgs.hasChanges).toBe(true);

    const startMs = Date.now();
    
    const sr = await em.saveChanges();
    const r = sr.entities;
    expect(r.length).toBe(80);
    const endMs = Date.now();
    const elapsed = (endMs - startMs) / 1000;
    expect(elapsed).toBeGreaterThan(0);
  });

  test("bigsave many children", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    let recentArgs: HasChangesChangedEventArgs;
    em.hasChangesChanged.subscribe(function (args) {
      recentArgs = args;
    });
    for (let i = 0; i < 5; i++) {
      const zzz = SaveTestFns.createParentAndManyChildren(em);
    }
    expect(recentArgs.hasChanges).toBe(true);
    const startMs = Date.now();
    const sr = await em.saveChanges();
    const r = sr.entities;
    expect(r.length).toBeGreaterThan(100);
    const endMs = Date.now();
    const elapsed = (endMs - startMs) / 1000;
    expect(elapsed).toBeGreaterThan(0);
  });

  test("noop", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Customers");

    const data = await q.using(em).execute();
    const sr = await em.saveChanges();
    expect(Array.isArray(sr.entities));
    expect(sr.entities.length).toBe(0);
    expect(em.hasChanges()).toBeFalse();
  });

  // is unsupported because MySQL does not support millisecond resolution").
  skipTestIf(TestFns.isSequelizeServer || TestFns.isHibernateServer, 
    "data with millseconds - UTC time - IE bug", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const dt = new Date(Date.parse("2012-12-17T13:35:15.690Z"));
    const offset = dt.getTimezoneOffset() * 60000;
    const dt1 = new Date(dt.getTime() - offset);
    const dt2 = new Date(dt.getTime() + offset);
    const ms = dt.getUTCMilliseconds();
    expect(ms).toBe(690);
    const q = new EntityQuery("Orders").where("shippedDate", "!=", dt).take(1);

    
    const qr1 = await q.using(em).execute();
    const order = qr1.results[0];
    order.setProperty("shippedDate", dt);
    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(1);
    const sameOrder = sr.entities[0];
    expect(order).toBe(sameOrder);
    const sameDt = sameOrder.getProperty("shippedDate");
    expect(dt.getTime()).toBe(sameDt.getTime());
    const em2 = TestFns.newEntityManager();
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em2).execute();
    const order2 = data2.results[0];
    const sameDt2 = order2.getProperty("shippedDate");
    expect(dt.getTime()).toBe(sameDt2.getTime());
  });

  // is unsupported because MySQL does not support millisecond resolution").
  skipTestIf(TestFns.isSequelizeServer || TestFns.isHibernateServer, 
    "data with millseconds - local time", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    // Date.parse("2012-12-17T13:35:15.690");
    const dt = new Date(2012, 11, 17, 13, 35, 15, 690); // local time
    const ms = dt.getMilliseconds();
    expect(ms).toBe(690);
    const q = new EntityQuery("Orders").take(1);
   
    const qr1 = await q.using(em).execute();
    const order = qr1.results[0];
    order.setProperty("shippedDate", dt);
    const sr = await em.saveChanges();
    expect(sr.entities.length).toBe(1);
    const sameOrder = sr.entities[0];
    expect(order).toBe(sameOrder);
    const sameDt = sameOrder.getProperty("shippedDate");
    expect(dt.getTime()).toBe(sameDt.getTime());
    const em2 = TestFns.newEntityManager();
    const q2 = EntityQuery.fromEntities(order);
    const data2 = await q2.using(em2).execute();
    const order2 = data2.results[0];
    const sameDt2 = order2.getProperty("shippedDate");
    expect(dt.getTime()).toBe(sameDt2.getTime());
  });



  test("date", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery("Orders").where("orderDate", '!=', null).take(10);

    const qr1 = await q.using(em).execute();
    const r = qr1.results;
    expect(r.length).toBeGreaterThan(0);
    const order = r[0];
    const orderDate = order.getProperty("orderDate");
    expect(core.isDate(orderDate));
    let day = orderDate.getDate();
    day = day < 31 ? day + 1 : 1;
    const newOrderDate = new Date(orderDate.getTime());
    newOrderDate.setDate(day);
    expect(core.isDate(newOrderDate)).toBeTrue();
    order.setProperty("orderDate", newOrderDate);
    const sr = await em.saveChanges();
    expect(Array.isArray(sr.entities)).toBeTrue();
    expect(sr.entities.length).toBe(1);
    expect(!em.hasChanges());
    expect(sr.entities[0]).toBe(order);
    const newOrderDate2 = order.getProperty("orderDate");
    expect(core.isDate(newOrderDate2)).toBeTrue();
    expect(newOrderDate.getTime()).toBe(newOrderDate2.getTime());
    expect(orderDate).not.toBe(newOrderDate2);
  });

  test("unmapped", async function () {
    expect.hasAssertions();
    // use a different metadata store for this em - so we don't polute other tests
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = function () {
      this.miscData = "asdf";
    };
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const q = new EntityQuery("Customers")
      .where("companyName", "startsWith", "C");
    const qr1 = await q.using(em1).execute();
    const customers = qr1.results;
    customers.every(function (c) {
      expect(c.getProperty("miscData")).toBe("asdf");
    });
    const cust = customers[0];
    cust.setProperty("miscData", "xxx");
    expect(cust.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(em1.hasChanges()).toBeFalse();
    const sr = await em1.saveChanges();
    const saved = sr.entities;
    expect(saved.length).toBe(0);
    expect(em1.hasChanges()).toBeFalse();
  });

  test("unmapped with ES5 props", async function () {
    expect.hasAssertions();
    // use a different metadata store for this em - so we don't polute other tests
    const em1 = TestFns.newEntityManager(MetadataStore.importMetadata(TestFns.defaultMetadata));
    const Customer = TestFns.getCustomerWithES5PropsCtor();

    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    const q = new EntityQuery("Customers")
      .where("companyName", "startsWith", "C");
    const qr1 = await q.using(em1).execute();
    const customers = qr1.results;
    customers.every(function (c) {
      expect(c.getProperty("miscData")).toBe("asdf");
    });
    const cust = customers[0];
    cust.setProperty("miscData", "xxx");
    expect(cust.entityAspect.entityState).toBe(EntityState.Unchanged);
    expect(em1.hasChanges()).toBeFalse();
    const sr = await em1.saveChanges();
    const saved = sr.entities;
    expect(saved.length).toBe(0);
    expect(em1.hasChanges()).toBeFalse();
  });

  test("add parent and children", async function () {
    expect.hasAssertions();
    const customerKeyName = TestFns.wellKnownData.keyNames.customer;
    const orderKeyName = TestFns.wellKnownData.keyNames.order;
    const em = TestFns.newEntityManager();
    let recentArgs: HasChangesChangedEventArgs;
    em.hasChangesChanged.subscribe(function (args) {
      recentArgs = args;
    });
    const zzz = SaveTestFns.createParentAndChildren(em);
    expect(recentArgs.hasChanges).toBe(true);

    const saveResult = await em.saveChanges(null, null);
    expect(recentArgs.hasChanges).toBe(false);
    expect(zzz.cust1.entityAspect.entityState.isUnchanged());
    expect(zzz.cust2.entityAspect.entityState.isUnchanged());
    expect(zzz.order1.entityAspect.entityState.isUnchanged());
    expect(zzz.order2.entityAspect.entityState.isUnchanged());
    expect(zzz.cust1.getProperty(customerKeyName)).not.toBe(zzz.keyValues[0]);
    expect(zzz.cust2.getProperty(customerKeyName)).not.toBe(zzz.keyValues[1]);
    expect(zzz.order1.getProperty(orderKeyName)).not.toBe(zzz.keyValues[2]);
    expect(zzz.order2.getProperty(orderKeyName)).not.toBe(zzz.keyValues[3]);
    expect(zzz.order1.getProperty("customer")).toBe(zzz.cust1);
    expect(zzz.order2.getProperty("customer")).toBe(zzz.cust1);
    expect(zzz.cust1.getProperty("orders").length).toBe(2);
    expect(zzz.cust2.getProperty("orders").length).toBe(0);
    expect(em.hasChanges()).toBeFalse();
  });

  test("allowConcurrentSave with concurrency column", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    const q = new EntityQuery()
      .from("Customers")
      .take(2);


    try {
      const qr1 = await em.executeQuery(q);
      const cust = qr1.results[0];
      TestFns.morphStringProp(cust, "companyName");
      await Promise.all([em.saveChanges(), em.saveChanges()]);
      throw new Error('should not get here');
      // one save should have failed for concurrency reasons
    } catch (e) {
      const msg = e.message;
      if (TestFns.isAspCoreServer) {
        expect(msg).toMatch(/Data may have been modified or/);
      } else if (TestFns.isAspWebApiServer) {
        expect(msg).toMatch(/Store update, insert/);
      } else if (TestFns.isHibernateServer) {
        expect(msg).toMatch(/Row was updated or deleted by another transaction/);
        
      } else if (TestFns.isSequelizeServer) {
        expect(msg).toMatch(/concurrency violation/);
      } else {
        throw new Error('unknown server');
      }
    }

  });

  // Issue with Sequelize on this one because Sequelize seems to run both under
  // same trx... not sure... but it might have to do with Isolation levels ...
  skipTestIf(TestFns.isSequelizeServer,
    "allow concurrent saves with NO concurrency column", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    const q = new EntityQuery()
      .from("Products")
      .take(2);

    const qr2 = await em.executeQuery(q);
    const prod = qr2.results[0];
    const price = prod.getProperty("unitPrice");
    prod.setProperty("unitPrice", price + 0.01);
    const x = await Promise.all([em.saveChanges(), em.saveChanges()]);
    // expect both to succeed
    expect(true).toBe(true);

  });

  test("disallow concurrent saves with NO concurrency column", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    // Next line is not needed because it is the default
    // em.saveOptions = new SaveOptions({ allowConcurrentSaves: false });
    const q = new EntityQuery().from("Products").take(2);

    try {
      const qr1 = await em.executeQuery(q);
      // query cust
      const prod = qr1.results[0];
      const price = prod.getProperty("unitPrice");
      prod.setProperty("unitPrice", price + .01);
      await Promise.all([em.saveChanges(), em.saveChanges()]);
      throw new Error("expected only one to complete");
    } catch (e) {
      expect(e.message).toMatch(/allowConcurrentSaves/);
    }
  });

  test("modify one", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const query = new EntityQuery()
      .from("Customers")
      .where("companyName", "startsWith", "C")
      .take(2);

    const qr1 = await em.executeQuery(query);
    const cust = qr1.results[0];
    const orders = cust.getProperty("orders");
    const companyName = cust.getProperty("companyName");
    const newCompanyName = TestFns.morphString(companyName);
    cust.setProperty("companyName", newCompanyName);
    const saveResult = await em.saveChanges();
    expect(em.hasChanges()).toBeFalse();
    const entities = saveResult.entities;
    expect(entities.length).toBe(1);
    expect(saveResult.keyMappings.length).toBe(0);
    expect(entities[0]).toBe(cust);
    expect(cust.getProperty("companyName")).toBe(newCompanyName);
    expect(cust.entityAspect.entityState.isUnchanged()).toBeTrue();
    const q2 = EntityQuery.fromEntities(cust);
    const data2 = await em.executeQuery(q2);
    const entities2 = data2.results;
    expect(entities2.length).toBe(1);
    expect(entities2[0]).toBe(cust);
    expect(cust.getProperty("companyName")).toBe(newCompanyName);
  });

  test("modify parent and children", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
   
    const savedCust = await SaveTestFns.saveNewCustAndOrders(em);
    const cust = savedCust;
    if (cust == null) {
      throw new Error("Test error - need a customer with orders");
    }
    const companyName = cust.getProperty("companyName");
    const newCompanyName = TestFns.morphStringProp(cust, "companyName");
    expect(cust.entityAspect.entityState.isModified()).toBeTrue();
    const orders = cust.getProperty("orders");
    orders.forEach(function (o: Entity) {
      TestFns.morphStringProp(o, "shipName");
      expect(o.entityAspect.entityState.isModified()).toBeTrue();
    });
    const saveResult = await em.saveChanges();
    expect(em.hasChanges()).toBeFalse();
    const entities = saveResult.entities;
    expect(entities.length).toBe(1 + orders.length);
    expect(saveResult.keyMappings.length).toBe(0);
    entities.forEach(function (e) {
      expect(e.entityAspect.entityState.isUnchanged()).toBeTrue();
      if (e.entityType === cust.entityType) {
        expect(e).toBe(cust);
      } else {
        expect(orders).toContain(e);
      }
    });
    expect(cust.getProperty("companyName")).toBe(newCompanyName);
    expect(cust.entityAspect.entityState.isUnchanged()).toBeTrue();
    const q2 = EntityQuery.fromEntities(cust);
    const data2 = await em.executeQuery(q2);
    const entities2 = data2.results;
    expect(entities2.length).toBe(1);
    expect(entities2[0]).toBe(cust);
    expect(cust.getProperty("companyName")).toBe(newCompanyName);
  });

  test("delete parent, children stranded", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    zzz.cust1.entityAspect.setDeleted();
    const order1custid = zzz.order1.getProperty("customerID");
    expect(order1custid).toBeNull();
    const sr = await em.saveChanges();
    expect(true).toBe(true);
  });

  test("delete parent, then clear", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    expect(!em.hasChanges());
    zzz.cust1.entityAspect.setDeleted();
    zzz.order1.entityAspect.setDeleted();
    zzz.order2.entityAspect.setDeleted();
    expect(zzz.order1.entityAspect.entityState.isDeleted()).toBeTrue();
    expect(zzz.cust1.entityAspect.entityState.isDeleted()).toBeTrue();
    expect(em.hasChanges());
    const sr = await em.saveChanges();
    expect(sr).toBeTruthy();
    // just to insure that 'clear' works 
    em.clear();

  });

  test("delete parent then delete children", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    expect(!em.hasChanges());
    zzz.cust1.entityAspect.setDeleted();
    zzz.order1.entityAspect.setDeleted();
    zzz.order2.entityAspect.setDeleted();
    expect(zzz.order1.entityAspect.entityState.isDeleted()).toBeTrue();
    expect(zzz.cust1.entityAspect.entityState.isDeleted()).toBeTrue();
    expect(em.hasChanges());
    const sr = await em.saveChanges();
    expect(!em.hasChanges());
    expect(sr.entities.length).toBe(3);
    expect(zzz.order1.entityAspect.entityState.isDetached()).toBeTrue();
    expect(zzz.order2.entityAspect.entityState.isDetached()).toBeTrue();
    expect(zzz.cust1.entityAspect.entityState.isDetached()).toBeTrue();
  });

  test("delete children then delete parent", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    const orders = zzz.cust1.getProperty("orders");
    expect(zzz.order1).toBe(orders[0]);
    const cust1a = zzz.order1.getProperty("customer");
    expect(cust1a).toBe(zzz.cust1);
    zzz.order1.entityAspect.setDeleted();
    zzz.order2.entityAspect.setDeleted();
    zzz.cust1.entityAspect.setDeleted();
    expect(zzz.order1.entityAspect.entityState.isDeleted()).toBeTrue();
    expect(zzz.cust1.entityAspect.entityState.isDeleted()).toBeTrue();
    const sr = await em.saveChanges();
    expect(!em.hasChanges());
    expect(sr.entities.length).toBe(3);
    expect(zzz.order1.entityAspect.entityState.isDetached()).toBeTrue();
    expect(zzz.order2.entityAspect.entityState.isDetached()).toBeTrue();
    expect(zzz.cust1.entityAspect.entityState.isDetached()).toBeTrue();
  });

  test("delete children then delete parent after query", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const em2 = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    const q = EntityQuery.fromEntities(zzz.cust1);
    const q1 = EntityQuery.from("Customers").where(q.wherePredicate);
    const qr1 = await em2.executeQuery(q1);
    // this step is to avoid having to do an expand above
    const cust = qr1.results[0];
    const data2 = await cust.entityAspect.loadNavigationProperty("orders");
    const orders = cust.getProperty("orders").slice(0);
    orders.forEach(function (o: Entity) {
      o.entityAspect.setDeleted();
    });
    cust.entityAspect.setDeleted();
    expect(orders[0].entityAspect.entityState.isDeleted()).toBeTrue();
    expect(cust.entityAspect.entityState.isDeleted()).toBeTrue();
    const sr = await em2.saveChanges();
    expect(em2.hasChanges()).toBeFalse();
    expect(sr.entities.length).toBe(3);
    sr.entities.forEach(function (e) {
      expect(e.entityAspect.entityState.isDetached()).toBeTrue();
    });
  });

  test("delete children, leave parent alone", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    zzz.order1.entityAspect.setDeleted();
    expect(zzz.cust1.getProperty("orders").length).toBe(1);
    zzz.order2.entityAspect.setDeleted();
    expect(zzz.cust1.getProperty("orders").length).toBe(0);
    expect(zzz.order1.entityAspect.entityState.isDeleted()).toBeTrue();
    expect(zzz.cust1.entityAspect.entityState.isUnchanged()).toBeTrue();
    const sr = await em.saveChanges();
    expect(!em.hasChanges());
    expect(zzz.order1.entityAspect.entityState.isDetached()).toBeTrue();
    expect(zzz.cust1.getProperty("orders").length).toBe(0);
  });

  test("delete parent, move children", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const zzz = SaveTestFns.createParentAndChildren(em);

    const saveResult = await em.saveChanges();
    zzz.cust1.entityAspect.setDeleted();
    zzz.order1.setProperty("customer", zzz.cust2);
    expect(zzz.order1.entityAspect.entityState.isModified()).toBeTrue();
    zzz.order2.setProperty("customer", zzz.cust2);
    expect(zzz.cust1.entityAspect.entityState.isDeleted()).toBeTrue();
    const sr2 = await em.saveChanges();
    expect(!em.hasChanges());
    expect(sr2.entities.length).toBe(3);
    expect(zzz.cust1.entityAspect.entityState.isDetached()).toBeTrue();
    expect(zzz.order1.entityAspect.entityState.isUnchanged()).toBeTrue();
  });


  // hibernate,sequelize: do not have a TimeGroup table
  // odata: does not support this feature
  skipTestIf(TestFns.isSequelizeServer || TestFns.isHibernateServer || TestFns.isODataServer, 
   "insert using existing entity re-attached", async function () {
    expect.hasAssertions();
    const em = TestFns.newEntityManager();
    const q = new EntityQuery()
      .from("TimeGroups")
      .take(2);
    let tg;

    const qr1 = await em.executeQuery(q);
    if (qr1.results.length === 0) {
      tg = em.createEntity("TimeGroup", { comment: "trigger" });
    } else {
      tg = qr1.results[0];
      TestFns.morphStringProp(tg, "comment");
    }
    const sr = await em.saveChanges();
    const tg1 = sr.entities[0];
    expect(tg1).toBe(tg);
    em.detachEntity(tg);
    tg.Id = -1;
    em.attachEntity(tg, EntityState.Added);
    tg.setProperty("comment", "This was re-attached");
    const sr2 = await em.saveChanges();
    expect(sr2).toBeTruthy();
  });

  //TestFns.skipIf("odata", "does not support custom server side key generation").
  // skipTestIf(TestFns.isODataServer
  test("insert with generated key", async function () {
    expect.hasAssertions();
    const em = SaveTestFns.newEntityManager();

    const region1 = SaveTestFns.createRegion(em, "1");
    const k1 = region1.entityAspect.getKey();

    const region2 = SaveTestFns.createRegion(em, "2");
    const k2 = region2.entityAspect.getKey();

    const data = await em.saveChanges();
    expect(em.hasChanges()).toBeFalse();
    expect(data.entities.length).toBe(2);
    expect(!region1.entityAspect.getKey().equals(k1));
    expect(!region2.entityAspect.getKey().equals(k2));
    const data2 = data;
    // curious about synchronous results
    expect(data2.entities.length).toBe(2);
  });

  //TestFns.skipIf("odata", "does not support custom server side key generation").
  test("insert uni (1-n) relationships with generated key", async function () {
    expect.hasAssertions();
    const em = SaveTestFns.newEntityManager();
    const regionKeyName = TestFns.wellKnownData.keyNames.region;
    const region1 = SaveTestFns.createRegion(em, "1");
    const k1 = region1.entityAspect.getKey();
    const terrs1 = region1.getProperty("territories");
    const terr1a = SaveTestFns.createTerritory(em, "test 1a");
    const terr1b = SaveTestFns.createTerritory(em, "test 1b");
    terrs1.push(terr1a);
    terrs1.push(terr1b);

    const region2 = SaveTestFns.createRegion(em, "2");
    const k2 = region2.entityAspect.getKey();
    const terrs2 = region2.getProperty("territories");
    const terr2a = SaveTestFns.createTerritory(em, "test 2a");
    const terr2b = SaveTestFns.createTerritory(em, "test 2b");
    terrs2.push(terr2a);
    terrs2.push(terr2b);

    expect(region1.getProperty("territories").length).toBe(2);
    expect(region2.getProperty("territories").length).toBe(2);

    const em2 = SaveTestFns.newEntityManager();
    const data = await em.saveChanges();
    expect(!em.hasChanges());
    expect(data.entities.length).toBe(6);
    expect(!region1.entityAspect.getKey().equals(k1));
    const terrs1x = region1.getProperty("territories");
    expect(terrs1x).toBe(terrs1);
    expect(terrs1x.length).toBe(2);
    expect(!region2.entityAspect.getKey().equals(k2));
    const terrs2x = region2.getProperty("territories");
    expect(terrs2x).toBe(terrs2);
    expect(terrs2x.length).toBe(2);
    expect(terrs2x[0].getProperty("regionID")).toBe(region2.getProperty(regionKeyName));
    // now move them all onto region1;
    terrs2x.slice(0).forEach(function (t: Entity) {
      t.setProperty("regionID", region1.getProperty(regionKeyName));
    });
    expect(terrs1x.length).toBe(4);
    expect(terrs2x.length).toBe(0);
    const sr2 = await em.saveChanges();
    expect(sr2.entities.length).toBe(2);
    expect(terrs1x.length).toBe(4);
    expect(terrs2x.length).toBe(0);
    const qr3 = await EntityQuery.fromEntities(region1).using(em2).execute();
    const region1y = qr3.results[0];
    const terrs1y = region1y.getProperty("territories");
    const qr4 = await terrs1y.load();
    expect(qr4.results.length).toBe(4);
    expect(terrs1y.length).toBe(4);
  });

  //TestFns.skipIf("odata", "does not support custom server side key generation").
  test("insert uni (1-n) relationships with generated key - v2", async function () {
    expect.hasAssertions();
    const regionKeyName = TestFns.wellKnownData.keyNames.region;
    const em = SaveTestFns.newEntityManager();
    const em2 = SaveTestFns.newEntityManager();

    const region1 = SaveTestFns.createRegion(em, "1");
    const k1 = region1.entityAspect.getKey();
    const terrs1 = region1.getProperty("territories");
    const terr1a = SaveTestFns.createTerritory(em, "test 1a");
    const terr1b = SaveTestFns.createTerritory(em, "test 1b");
    terr1a.setProperty("regionID", region1.getProperty(regionKeyName));
    terr1b.setProperty("regionID", region1.getProperty(regionKeyName));

    const region2 = SaveTestFns.createRegion(em, "2");
    const k2 = region2.entityAspect.getKey();
    const terrs2 = region2.getProperty("territories");
    const terr2a = SaveTestFns.createTerritory(em, "test 2a");
    const terr2b = SaveTestFns.createTerritory(em, "test 2b");
    terr2a.setProperty("regionID", region2.getProperty(regionKeyName));
    terr2b.setProperty("regionID", region2.getProperty(regionKeyName));

    expect(region1.getProperty("territories").length).toBe(2);
    expect(region2.getProperty("territories").length).toBe(2);

    const data = await em.saveChanges();
    expect(!em.hasChanges());
    expect(data.entities.length).toBe(6);
    expect(!region1.entityAspect.getKey().equals(k1));
    const terrs1x = region1.getProperty("territories");
    expect(terrs1x).toBe(terrs1);
    expect(terrs1x.length).toBe(2);
    expect(region2.entityAspect.getKey()).not.toEqual(k2);
    const terrs2x = region2.getProperty("territories");
    expect(terrs2x).toBe(terrs2);
    expect(terrs2x.length).toBe(2);
    expect(terrs2x[0].getProperty("regionID")).toBe(region2.getProperty(regionKeyName));
    // now move them all onto region1;
    terrs2x.slice(0).forEach(function (t: any) {
      terrs1x.push(t);
    });
    expect(terrs1x.length).toBe(4);
    expect(terrs2x.length).toBe(0);
    const sr2 = await em.saveChanges();
    expect(sr2.entities.length).toBe(2);
    expect(terrs1x.length).toBe(4);
    expect(terrs2x.length).toBe(0);
    const qr3 = await EntityQuery.fromEntities(region1).expand("territories").using(em).execute();
    expect(qr3.results.length).toBe(1);
    expect(region1).toBe(qr3.results[0]);
    expect(terrs1x.length).toBe(4);
    const data4 = await EntityQuery.fromEntities(region1).expand("territories").using(em2).execute();
    expect(data4.results.length).toBe(1);
    const terrs1y = data4.results[0].getProperty("territories");
    expect(terrs1y.length).toBe(4);
  });

  //TestFns.skipIf("odata", "does not support custom server side key generation (except identity)").
  test("insert uni (1-n) relationships with unattached children - v3", async function () {
    expect.hasAssertions();
    const regionKeyName = TestFns.wellKnownData.keyNames.region;
    const em = SaveTestFns.newEntityManager();
    const em2 = SaveTestFns.newEntityManager();

    const region1 = SaveTestFns.createRegion(em, "1");
    const k1 = region1.entityAspect.getKey();
    const terrs1 = region1.getProperty("territories");
    const terr1a = SaveTestFns.createTerritory(em, "test 1a");
    const terr1b = SaveTestFns.createTerritory(em, "test 1b");
    terr1a.setProperty("regionID", region1.getProperty(regionKeyName));
    terr1b.setProperty("regionID", region1.getProperty(regionKeyName));

    const region2 = SaveTestFns.createRegion(em, "2");
    const k2 = region2.entityAspect.getKey();
    const terrs2 = region2.getProperty("territories");
    const terr2a = SaveTestFns.createTerritory(em, "test 2a");
    const terr2b = SaveTestFns.createTerritory(em, "test 2b");
    terr2a.setProperty("regionID", region2.getProperty(regionKeyName));
    terr2b.setProperty("regionID", region2.getProperty(regionKeyName));

    expect(region1.getProperty("territories").length).toBe(2);
    expect(region2.getProperty("territories").length).toBe(2);

    const qr1 = await em.saveChanges();
    expect(!em.hasChanges());
    expect(qr1.entities.length).toBe(6);
    expect(!region1.entityAspect.getKey().equals(k1));
    const territories = em.getEntities("Territory");
    const qr2 = await EntityQuery.fromEntities(territories).using(em2).execute();
    expect(qr2.results.length).toBe(4);
    const qr3 = await EntityQuery.fromEntities(region1).using(em2).execute();
    expect(qr3.results.length).toBe(1);
    const region1a = qr3.results[0];
    const terrs1a = region1a.getProperty("territories");
    expect(terrs1a.length).toBe(2);
  });

  test("save of deleted entity should not trigger validation", async function () {
    expect.hasAssertions();
    // TODO: OData bug here is because of region - AutoGeneratedKeyType
    const em = TestFns.newEntityManager();
    const cust = SaveTestFns.createCustomer(em);

    expect(em.hasChanges());
    const sr = await em.saveChanges();
    expect(!em.hasChanges());
    expect(sr.entities.length).toBe(1);
    expect(sr.entities[0]).toBe(cust);
    cust.setProperty("companyName", "");
    cust.entityAspect.setDeleted();
    expect(em.hasChanges());
    const sr2 = await em.saveChanges();
    expect(!em.hasChanges());
    expect(sr2.entities.length).toBe(1);
    expect(sr2.entities[0]).toBe(cust);
    expect(cust.entityAspect.entityState.isDetached()).toBeTrue();
  });


  //TestFns.skipIf("mongo", "does not support 'expand'").
  


});
